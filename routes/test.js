var articleList = [{
        _id: '5a4f3f12c4780dbc7f6b4f3d',
        category_name: 'html',
        isSaved: '2',
        article_title: 'HTML meta标签常用属性及其作用总结',
        __v: 0,
        date: new Date('2018-01-05')
    },
    {
        _id: '5a4f40aac4780dbc7f6b4f3f',
        category_name: 'html',
        isSaved: '2',
        article_title: '创建一个完整的HTML文档总结',
        __v: 0,
        date: new Date('2018-01-05')
    },
    {
        _id: '5a4f40e5c4780dbc7f6b4f41',
        category_name: 'javaScript',
        isSaved: '2',
        article_title: 'JavaScript delete操作符全总结',
        __v: 0,
        date: new Date('2018-01-05')
    },
    {
        _id: '5a4f410cc4780dbc7f6b4f43',
        category_name: 'javaScript',
        isSaved: '2',
        article_title: 'JavaScript Array sort方法总结',
        __v: 0,
        date: new Date('2018-01-05')
    },
    {
        _id: '5a4f4278c4780dbc7f6b4f45',
        category_name: 'http',
        isSaved: '2',
        article_title: '通过nodejs搭建简单的本地服务，浅谈http中的请求头request headers',
        __v: 0,
        date: new Date('2018-01-05')
    },
    {
        _id: '5a4f42d0c4780dbc7f6b4f47',
        category_name: 'javaScript',
        isSaved: '2',
        article_title: 'js执行机制、事件循环、执行栈、执行环境(上下文)、作用域、作用域链、活动对象、变量对象的概念总结',
        __v: 0,
        date: new Date('2018-01-05')
    },
    {
        _id: '5a4f431dc4780dbc7f6b4f4b',
        category_name: 'javaScript',
        isSaved: '2',
        article_title: 'js中的Object.defineProperty()和defineProperties()',
        __v: 0,
        date: new Date('2018-01-05')
    },
    {
        _id: '5a4f434fc4780dbc7f6b4f4d',
        category_name: 'vue',
        isSaved: '2',
        article_title: 'js简易版的vue数据双向绑定',
        __v: 0,
        date: new Date('2018-01-05')
    },
    {
        _id: '5a4f436dc4780dbc7f6b4f4f',
        category_name: 'javaScript',
        isSaved: '2',
        article_title: 'js中的面向对象、原型、原型链、继承',
        __v: 0,
        date: new Date('2018-01-05')
    },
    {
        _id: '5a4f43bdc4780dbc7f6b4f51',
        category_name: 'javaScript',
        isSaved: '2',
        article_title: 'js中的正则表达式',
        __v: 0,
        date: new Date('2018-01-05')
    },
    {
        _id: '5a4f43dac4780dbc7f6b4f53',
        category_name: 'javaScript',
        isSaved: '2',
        article_title: 'js中的闭包',
        __v: 0,
        date: new Date('2018-01-05')
    }
]

var articleContentList = [{
    "_id": "5a4f3f49c4780dbc7f6b4f3e",
    "article_id": "5a4f3f12c4780dbc7f6b4f3d",
    "article_title": "HTML meta标签常用属性及其作用总结",
    "article_content": "文章同步到[github](https://github.com/sunzhaoye/blog/issues/2)\n\n以前没怎么太注意过meta标签的作用，只是简单了解一些常用属性，现在结合个人了解的进行记录与总结:\n\n# 元数据\n\n>首先需要了解一下**元数据(metadata)元素**的概念，用来构建HTML文档的基本结构，以及就如何处理文档向浏览器提供信息和指示，它们本身不是文档内容，但提供了关于后面文档内容的信息。——出自《html5权威指南》\n\n如title、base、meta都是元数据元素。本文主要介绍<meta>。\n\n## <meta>元素\n[<meta>](http://www.w3school.com.cn/tags/tag_meta.asp)  元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词。--W3school\n\n<meta>元素可以定义文档的各种元数据，提供各种文档信息，通俗点说就是可以理解为提供了关于网站的各种信息。html文档中可以包含多个<meta>元素，每个<meta>元素只能用于一种用途，如果想定义多个文档信息，则需要在head标签中添加多个meta元素。\n\n| 元素     |                             meta |\n| -------- | --------|\n| 父元素     |                             head |\n| 属性  | http-equiv、name、content、charset |\n| HTML5中的变化 |1. charset为HTML5中新增的，用来声明字符编码;2. http-equiv属性在HTML4中有很多值，在HTML5中只有refresh、default-style、content-type可用|\n\n### <meta>具体用途\n<meta>元素出去charset属性外，都是http-equiv属性或name属性结合content来使用\n\n#### 1. 指定名/值对定义元数据\nname属性与content属性结合使用, name用来表示元数据的类型，表示当前<meta>标签的具体作用；content属性用来提供值。\n```\n<meta name=\"参数\" content=\"具体描述信息\">\n```\n例如:  \n```\n<!DOCTYPE HTML>\n<html>\n    <head>\n        <title>demo</title>\n        <meta name=\"keywords\" content=\"电商,物流\">\n        <meta name=\"author\" content=\"张三\">\n        <meta name=\"description\" content=\"网站描述...\">\n    </head>\n    <body>\n        <div>welcome</div>\n    </body>\n</html>\n```\n| 元数据名称(name的值)| 说明 |\n| - | --|\n| application name     |当前页所属Web应用系统的名称 |\n|  keywords | 描述网站内容的关键词,以逗号隔开，用于SEO搜索 |\n|  description | 当前页的说明 |\n|  author | 当前页的作者名 |\n|  copyright | 版权信息 |\n|  renderer | renderer是为双核浏览器准备的，用于指定双核浏览器默认以何种方式渲染页面|\n\n**renderer**\n```\n<meta name=\"renderer\" content=\"webkit\"> //默认webkit内核 \n<meta name=\"renderer\" content=\"ie-comp\"> //默认IE兼容模式 \n<meta name=\"renderer\" content=\"ie-stand\"> //默认IE标准模式\n\n<meta name=\"renderer\" content=\"webkit|ie-comp|ie-stand\">\n```\n\n\n\n#### 2. 声明字符编码\ncharset属性为HTML5新增的属性，用于声明字符编码,以下两种写法效果一样\n```\n<meta charset=\"utf-8\"> //HTML5\n```\n```\n<meta http-equiv=\"content-Type\" content=\"text/html;charset=utf-8\"> //旧的HTML\n```\n#### 3. 模拟http标头字段\n**http-equiv**属性与**content**属性结合使用, **http-equiv**属性为指定所要模拟的标头字段的名称，**content**属性用来提供值。\n```\n<meta http-equiv=\"参数\" content=\"具体的描述\">\n```\n**content-Type** 声明网页字符编码:\n```\n<meta http-equiv=\"content-Type\" content=\"text/html charset=UTF-8\">\n```\n**refresh** 指定一个时间间隔(以秒为单位),在此时间过去之后从服务器重新载入当前页面,也可以另外指定一个页面.\n```\n<meta http-equiv=\"refresh\" content=\"2;URL=http://www.baidu.com\">//2秒后在当前页跳转到百度\n``` \n**X-UA-Compatible** 浏览器采取何种版本渲染当前页面\n```\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"> //指定IE和Chrome使用最新版本渲染当前页面\n\n```\n**expires** 用于设定网页的到期时间，过期后网页必须到服务器上重新传输\n```\n<meta http-equiv=\"expires\" content=\"Sunday 22 July 2016 16:30 GMT\">\n```\n**catch-control** 用于指定所有缓存机制在整个请求/响应链中必须服从的指令\n```\n<meta http-equiv=\"cache-control\" content=\"no-cache\">//\n```\ncontent有以下值(百度百科):\n\n|content的值|说明|\n| -- | -- |\n| public |所有内容都将被缓存(客户端和代理服务器都可缓存)|\n| private |内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)|\n| no-cache |必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。|\n| no-store |所有内容都不会被缓存到缓存或 Internet 临时文件中|\n| must-revalidation/proxy-revalidation |如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证|\n| max-age=xxx (xxx is numeric) |缓存的内容将在 xxx 秒后失效, 这个选项只在HTTP 1.1可用, 并如果和Last-Modified一起使用时, 优先级较高|\n\n由于能力有限，结合demo总结以上<meta>元素的常用属性及其功能，可能有些纰漏，还望大家多多包含和指正，文章参考了《HTML权威指南》、[W3school](http://www.w3school.com.cn/tags/tag_meta.asp) 及相关博客[HTML meta标签总结与属性的使用介绍](http://www.imooc.com/article/4475)、[常用meta整理](https://segmentfault.com/a/1190000002407912)，在我能力外没有总结的可参考以上博客。后续有时间还会继续学习和更新此文章，希望能对大家有所帮助\n",
    "category_name": "html",
    "isSaved": "2",
    "date": new Date(1515142985312),
    "__v": 0
}, {
    "_id": "5a4f40bfc4780dbc7f6b4f40",
    "article_id": "5a4f40aac4780dbc7f6b4f3f",
    "article_title": "创建一个完整的HTML文档总结",
    "article_content": "# HTML文档\n>HTML指的是超文本标记语言 (Hyper Text Markup Language)，HTML文档就是我们常说的网页，一个标准的HTML文档由**文档元素**和**元数据元素**组成，二者用来创建HTML文档以及其内容。\n\n顺便说一下什么是元数据元素: 用来构建HTML文档的基本结构，以及就如何处理文档向浏览器提供信息和指示，它们本身不是文档内容，但提供了关于后面文档内容的信息。包含在head内，如title、base、meta等都是元数据元素。本文不做重点介绍。\n\n## 文档元素\n文档元素一共有四个**DOCTYPE**、**html**、**head**、**body**\n\n### DOCTYPE\n\n每一个HTML文档都必须由DOCTYPE元素开头，告诉浏览器要处理的是HTML文档，在HTML5中DOCTYPE 声明变得非常简单而且唯一，不用写版本号浏览器也能识别这是HTML5文档，因为和之前的HTML版本有所差异\n    <!DOCTYPE html> //HTML5声明\n\n在 HTML 4.01 中，<!DOCTYPE> 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。HTML5 不基于 SGML，所以不需要引用 DTD。--[W3school](http://www.w3school.com.cn/tags/tag_doctype.asp)\n\n**HTML4中声明如下:**\n\nHTML 4.01 Strict(不允许使用框架集):\n    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n\nHTML 4.01 Frameset(允许使用框架集):\n    <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">\n\n### html\nhtml表示根元素，表示HTML文档的开始，必须需要的元素，html具有如下属性:\n\n|属性|值|功能|\n| -- | -- | -- |\n|manifest|url|定义一个url，描述文档的缓存信息|\n| xmlns | \"http://www.w3.org/1999/xhtml\" |定义 XML namespace 属性(其实这个我也没用过不懂啊)，感兴趣的大神自己研究下吧|\n\n### head\n>包含文档的元数据，向浏览器提供文档内容和标记的信息，还包括脚本和对外资源的引用，如引入外联.css文件、js文件等。\n\n|包含元素|是否必须|功能|\n| -- | -- | -- |\n|title|是|必须有一个title元素，定义网站的标题|\n|base |否|设置一个基准URL，让HTML文档中的相对链接在此基础上解析|\n|meta |否|定义各种文档元数据，可见我的上一篇文章[<meta>常用属性总结](https://segmentfault.com/a/1190000010342600)|\n|style |否|1. 指定样式类型; 2. 指定样式作用范围; 3. 指定样式使用的媒体类型|\n|link |否|1. 载入外部样式表; 2. 为页面定义网站标志; 3. 预先获取关联资源 |\n|script |否|1. 定义文档内嵌脚本; 2. 载入外部脚本|\n|noscript |否|可以向禁用或不知JavaScript的浏览器展示一些内容|\n\n- **<base>介绍:**\n如果在浏览器地址为\"https://segmentfault.com/demo/index.html\"中载入一个文档，代码如下:\n```\n<DOCTYPE html>\n<html>\n    <head>\n        <base href=\"https://segmentfault.com/\">\n    </head>\n    <body>\n        <a href=\"page2.html\">跳转</a>\n    </body>\n</html>\n```\n正常点击a链接，浏览器将从\"https://segmentfault.com/page2.html\"中加载文档\n**如果不包含<base>元素**，浏览器将从\"https://segmentfault.com/demo/index.html\"中加载文档地址\n\n- **style**\n\nstyle元素拥有局部属性:type、scoped、media，其对应作用如下:\n\n**1.指定内嵌样式，type属性是高速浏览器文档所定义的类型、这个值只有一种text/css**\n```\n<style>\n    .box {\n        width: 200px;\n        height: 200px;\n        background: red;\n    }\n</style>\n```\n**2.指定样式范围，scoped属性的作用为style元素内定义的样式只作用于该元素的父级及其所有兄弟元素**\n\n\n**3.media属性表明文档在指定的设备下显示其定义的样式**\n```\n<style media=\"screen\" type=\"text/css\">\n    .box {\n        width: 200px;\n        height: 200px;\n        background: red;\n    }\n</style>\n```\nmedia属性所有的设备值如下表(--HTML5权威指南)，很多在工作中几乎都用不上，列出来了解一下及以备查阅:\n\n|设备(media的值)|说明|\n|--|--|\n|all|将样式用于所有设备(默认值)|\n|aural|将样式用于语音合成器|\n|braille|将样式用于盲文设备|\n|handheld|将样式用于手持设备|\n|projection|讲样式用于投影机|\n|print|将样式用于打印预览和打印页面时|\n|screen|将样式用于计算机显示屏幕|\n|tty|将样式用于电传打印机之类的等宽设备|\n|tv|将样式用于电视机|\n\nmedia不只能规定设备，还能定义更具体的使用条件，举例如下: \n```\n<style media=\"screen AND (max-width:500px)\" type=\"text/css\">\n//只在浏览器宽度小于500px的情况下生效\n    .box {\n        width: 200px;\n        height: 200px;\n        background: red;\n    }\n</style>\n```\n```\n<style media=\"screen AND (mix-width:500px)\" type=\"text/css\">\n//只在浏览器宽度大于500px的情况下生效\n    .box {\n        width: 200px;\n        height: 200px;\n        background: blue;\n    }\n</style>\n```\n除了用AND来定义具体条件，还可以使用NOT和OR(','表示)，另外还有其他供media使用的特性就不列举了，大家可以自己去百度了，再补充一个吧，device-width，这些特性都可以结合max-/mix-来使用\n\n- **link**\n\n拥有的局部属性如下表:\n\n|属性|说明|\n|--|--|\n|href|指定引入资源的URL|\n|hreflang|说明关联资源使用的语言|\n|media|说明关联内容用于哪种设备|\n|rel|说明文档与关联资源的关系类型，属性值决定了浏览器如何解析link元素|\n|sizes|HTML5中新增，指定网站图标大小|\n|type|指定所关联资源的[MIME](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types)类型，如text/css|\n\nrel属性常用值[rel值列表](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Link_types)及其表示的link元素功能\n\n|属性|说明|\n|--|--|\n|stylesheet|载入外部样式表|\n|icon|指定图标资源|\n|prefetch|预先获取一个资源|\n\n**1.引入外联样式表**\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"index.css\">\n    \n**2.添加网站图标**\n    <link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"favicon.ico\">\n     //href属性值为图片路径\n**3.预先获取关联的资源**\n    <link rel=\"prefetch\"  href=\"demo.html\">\nrel属性值设置为prefetch，可以预先加载demo.html，如果页面存在链接如下，为需要demo.html页面的操作做好准备\n```\n   <a href=\"demo.html\">demo</a>\n```\n- **script**\n\n>script元素可以定义页面内嵌脚本、引入外部文件脚本并通过script本身局部属性值设定加载脚本的各种方式\n\nscript的常用局部属性及其说明如下表:\n\n|属性|说明|\n|--|--|\n|type|表示引用或定义的脚本类型，如果是javascript脚本，此属性可以省略，省略type属性时浏览器默认为使用JavaScript脚本\n|src|指定加载外部脚本资源的URL|\n|defer|设定脚本执行的方式为延迟执行，告诉浏览器等页面载入和解析完毕才能执行此脚本，只能与src属性一起使用|\n|async|设定脚本执行的方式为异步执行，只能与src属性一起使用|\n|charset|说明外部脚本资源的字符编码，只能与src属性一起使用|\n\n**1.定义文档内嵌脚本** \n```\n<script>\n    window.onload = function() {\n        alert('页面加载完成');\n    } \n</script>\n```\n一般情况下script元素应该放在文档最后，等页面全部加载完成后才去执行，保证脚本文件内可以获取到当前页面的全部内容。\n\n如果script元素在head内，如果是当前内嵌脚本，则可以添加window.onload来告诉浏览器当所有页面全部加载完成才去执行。\n\n**2.载入外部脚本**\n    <script src=\"index.js\"></script>\n    \n**3.使用defer属性延迟加载外部脚本**\n    <script defer src=\"index.js\"></script>\n    \n如果在head中使用script元素，defer属性将会在HTML文档所有元素都解析完毕之后才加载和执行。\n\n*注意*:defer属性只能处理外部脚本，对内嵌脚本无效。\n\n**4.使用async属性异步执行脚本**\n    <script async src=\"index.js\"></script>\n\n浏览器在解析script元素时的默认行为是加载和执行脚本的时候暂停处理页面，各script元素按顺序同步执行。\n\n使用async属性可以使外部脚本在加载HTML时异步执行，如何使用需结合具体产品功能需求，不过带来的影响是，页面中的脚本不能再按次序同步执行，所以如果当前脚本中与其他脚本有关联，则不适合使用async属性\n\n### body\n\nHTML文档的元数据和文档信息都包含在head内，文档内容包含在body内，body紧跟在head后面，具体不在赘述！\n\n本文很多概念和属性表格结合《HTML5权威指南》、W3school、MDN，由于博主能力有限，很多概念直接拿过来引用，并附上相关链接，以保证其正确性，对HTML文档的相关知识作一个简单的总结，希望能帮助到需要的人，同时也方便自己后续查阅。\n  ",
    "category_name": "html",
    "isSaved": "2",
    "date": new Date(1515143359611),
    "__v": 0
}, {
    "_id": "5a4f40f3c4780dbc7f6b4f42",
    "article_id": "5a4f40e5c4780dbc7f6b4f41",
    "article_title": "JavaScript delete操作符全总结",
    "article_content": ">在JavaScript中，delete操作符用的比较少，但是还是比较重要的，我本人面试的时候就遇到过关于delete的问题，下面总结一下delete的具体用法。\n\n# 作用:\n\ndelete 操作符用于删除对象的某个属性。\n\n# 语法:\n直接使用delete操作符\n\n    delete object.property 或 delete object['property']\n\n例如:\n```\nvar person = {\n    name: 'abc'\n    age: 18\n}\n\ndelete person.name\n\nconsole.log(person) // {age: 18}\n```\n# 返回值:\n\ndelete操作符具有返回值，返回值为布尔值，对于所有情况都是true，即使是删除不存在的属性也会返回true，还是如上代码，不防打印一下返回值看看\n\n    console.log(delete person.name) //true\n    console.log(delete person.job) //即使删除对象不存在的属性依然返回true\n    \n    \n但是也有例外的情况(返回false)，如果属性是**不可配置属性**(对于不可配置属性的概念，可以参考[Object. defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)，我第一次听说这个概念的时候也有点蒙圈), 在非严格模式下，返回false，在严格模式下则会抛出语法错误的异常。\n\n# 具体使用\n## 1. 对象属性不存在\n如上所述，如果删除对象不存在的属性，delete无效，但是返回值仍然为true\n\n## 2. 原型链上存在该同名属性\n如果delete操作符删除属性成功，则该属性将永远不存在，但是该对象原型链上存在该同名属性，则该对象会从原型链上继承该同名属性。**但和内存并无关联，内存管理并不是delete操作符可以操作的，而且一点关系也没有。[内存管理](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management)推荐MDN这篇文章**\n```\n// 构造函数\nfunction Person() {\n    this.name = \"张三\",\n    this.job = \"工程师\"\n}\n\nPerson.prototype.name = \"李四\"\n// 创建实例对象\nvar p = new Person();\n// 只删除p实例的name属性\ndelete p.name;\nconsole.log(p) => // 通过打印如下图，name属性成功删除\n```\n\n![打印字段图片](http://ovqwwz784.bkt.clouddn.com/delete.png)\n\n```\n接下来看: \nconsole.log(p.name) => // '张三' 依然可以访问到\n```\n所以可以看出delete操作只会在自身的属性上起作用，这里能console出来'张三'，是作用域链的原因，当实例本身无该属性的时候，就会去找它的protype身上有无该同名属性。\n## 3. 使用var声明\n\n使用var声明的属性(包括函数)，不能从全局作用域或函数作用域中删除\n\n在全局作用域中声明属性:\n```\n// 声明属性\nvar a = 1; // 等同于window.a\ndelete a  // 严格模式下抛出语法异常 SyntaxError\nconsole.log(a); // 1 非严格模式下\nconsole.log(delete a); // 非严格模式下false\n```\n```\n// 声明函数\nvar fn = function () {\n    console.log(1);\n}\ndelete fn // 严格模式下抛出语法异常  SyntaxError\nfn() // 1 非严格模式下delete失效, 函数依然存在\n\n// 另外， 除字面量定义外，匿名函数定义函数效果也是一样\n```\n在函数作用域中声明属性(效果和在全局作用域中一样):\n\n```\n// 局部作用域声明属性\nfuntion fn() {\n    var a = 1;\n    delete a; // 严格模式下抛出语法异常 SyntaxError\n    console.log(a); // 1\n    console.log(delete a); // 非严格模式下false\n}\n\nfn();\n```\n```\n// 局部作用域声明函数\nvar fn = function() {\n    var fn2 = function() {\n        console.log(1);\n    };\n    delete fn2 // 严格模式下抛出语法异常 SyntaxError \n    console.log(delete fn2); // false 非严格模式下\n    fn2(); // 1\n}\nfn();\n```\n另外， 需要注意的是，在对象中定义的函数是可以删除的，和属性一样，比如\n\n```\nvar person = {\n    name: '张三',\n    showName: function () {\n        console.log(this.name);\n    }\n}\ndelete person.showName\nconsole.log(person.showName) // undefined\n```\n## 4. let和const声明的属性\n\n任何用let或const声明的属性不能够从它被声明的作用域中删除，我试了下，和var的效果是一样的，目前只能理解到这，如果知道的大神请指点下\n## 5. 不可设置的属性\n### Math, Array, Object等内置对象的属性不可删除 \n```\nconsole.log(Array.length); // 1\ndelete Array.length\nconsole.log(Array.from); 0\n```\n```\ndelete Array.prototype //严格模式下抛出异常\nconsole.log(Array.prototype) // 非严格模式下，prototype依然存在, 可以自己试试了，自己动手，丰衣足食\nconsole.log(Array.prototype.join); // 非严格模式下，join方法依然存在\n```\n需要注意的是，只是这些内置对象的属性不可删除，内置对象的方法是可以删除的，比如:\n\n```\nconsole.log(Array.forEach); // 内置函数\ndelete Array.forEach // 不用区分严格模式与否\nconsole.log(Array.forEach); // undefined\n```\n### Object.defineProperty()设置为不可设置的属性,不可删除\n\n```\nvar person = {};\nObject.defineProperty(person, 'name', {\n    value: '张三',\n    configurable: false\n})\ndelete person.name // 严格模式下，抛出异常\nconsole.log(person.name); // 张三\nconsole.log(delete person.name); // 非严格模式false\n```\n\n**var, let以及const创建的不可设置的属性不能被delete操作删除**\n```\nvar a = 'abc'; // 属于window 等同于window.a\nvar aVal = Object.getOwnPropertyDescriptor(window, 'a'); \nconsole.log(aVal);\n//  aVal输入如下   \n//    {\n//       value: 2,\n//         writable: true, \n//         enumerable: true, \n//         configurable: false // 由于是var声明的属性，所以为false\n//     }\n```\n```\nvar a = 'abc'; // 属于window 等同于window.a\ndelete a // 严格模式下抛出异常\nvar aVal = Object.getOwnPropertyDescriptor(window, 'a'); \nconsole.log(aVal);\nconsole.log(delete a); //false\n//  非严格模式下，aVal输入如下   \n//    {\n//       value: 2,\n//         writable: true, \n//         enumerable: true, \n//         configurable: false // 由于是var声明的属性，所以为false\n//     }\n```\n如果开始没有阅读，再去看看吧[Object. defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)。如果了解，可以直接略过。\n## 6. 删除数组\n使用delete操作符删除数组总某项元素时，被删除的元素会从该数组中删除，但是数组的length并不会改变\n\n```\nvar arr = [1, 2, 3];\ndelete arr[1]\nconsole.log(arr); // [1, undefined × 1, 2]\nconsole.log(delete arr[1]) // true\nconsole.log(arr[1]); // undefined\n```\n但是这里存在一个问题\n    console.log(1 in arr) // false\n\n所以如果想把数组中某一项赋值成undefined时，不应该使用delete操作符,而是直接使用下边赋值\n    arr[1] = undefined;\n    // 这样就可以解决上面的问题 \n    console.log(1 in arr) // true\n \n今天花了点时间，把关于delete的问题总结了一下, 方便自己查阅, 也希望能帮助需要的人, 欢迎大神指点与补充,如果你阅读完，感觉也还有收藏价值，那还等什么，赶快收藏吧！\n  ",
    "category_name": "javaScript",
    "isSaved": "2",
    "date": new Date(1515143411488),
    "__v": 0
}, {
    "_id": "5a4f4117c4780dbc7f6b4f44",
    "article_id": "5a4f410cc4780dbc7f6b4f43",
    "article_title": "JavaScript Array sort方法总结",
    "article_content": "## 使用方式\n\n| 参数      |    描述 |  返回值\n| :--------| :--------| :--------|\n| sortby | 可选，规定排序顺序，必须是函数 |对数组的引用，数组在原数组上进行排序，不生成副本|\n\n## 说明: \n- sort方法内如果不传参数, 则是比较数组内元素的[ASCII](https://baike.baidu.com/item/ASCII/309296?fr=aladdin)字符编码的值，即每次都会调用元素的toString()转换成字符串，按ASCII字符编码值进行比较\n- 若想按照其他方式进行排序，则需要传入比较函数(sort内的参数)，比较函数需要返回值，***当函数返回值为1的时候就交换两个数组项的顺序，否则就不交换***\n\n### 按照ASCII编码值进行比较\n```\nvar arr = ['apple', 'banana', 'pear', 'apricot', 'grape', 'JJJ'];\narr.sort();\n\n// arr =>  [\"JJJ\", \"apple\", \"apricot\", \"banana\", \"grape\", \"pear\"]\n\n因为J的ASCII值比a的小，所以J排在apple的前面\n```\n\n\n\n### 升序排列: \n```\nvar arr = [10, 2, 9, 3, 24, 6];\narr.sort(function(a, b) {\n\treturn a-b;\n});\n//arr => [2, 3, 6, 9, 10, 24]\n```   \n升序排列可以另写成:\n```\narr.sort(function(a, b) {\n    if (a<b) {\n        return -1; // a<b，-1表示不调换位置\n    } else if (a>b) {\n        return  1;// a>b, 1表示需要调换位置\n    } else {\n        return 0; // 不调换位置\n    }\n});    \n```\n### 降序排列: \n```\nvar arr = [10, 2, 9, 3, 24, 6];\n\tarr.sort(function(a, b) {\n\t\treturn b-a;\n\t});\n//arr => [24, 10, 9, 6, 3, 2]\n```\n降序排列可以另写成: \n```\narr.sort(function(a, b) {\n\tif (a<b) {\n        return 1 //表示需要调换a、 b的位置\n    } else if (a>b) {\n        return -1 // 表示不需要调换a、 b位置\n    } else {\n        return 0 // 表示不需要调换a、 b位置\n    }\n});\n```\n  ",
    "category_name": "javaScript",
    "isSaved": "2",
    "date": new Date(1515143447645),
    "__v": 0
}, {
    "_id": "5a4f4298c4780dbc7f6b4f46",
    "article_id": "5a4f4278c4780dbc7f6b4f45",
    "article_title": "通过nodejs搭建简单的本地服务，浅谈http中的请求头request headers",
    "article_content": ">现在回想工作刚开始的时候，和后端联调，对http的请求头一知半解，打开chrome控制台都有点蒙，随着工作中不断的摸索，也了解了很多。后来学习了node之后，通过nodejs来搭建简单的服务，自己对http通信中请求头(request headers)和响应头(response headers)有了稍微的认识，下面我会通过最最最简单的node服务来整理一下，也会贴一些代码，走起:\n\n##### 1. 通过nodejs搭建一个最简单的服务,监听8081端口:\n新建server.js文件，内容如下，后缀通过运行**node server**命令启动服务，node中启动服务通过运行node命令，后加文件名(server,可省略文件后缀js)启动服务\n\n```\n//server.js\n//node为模块开发，http为node内置模块，直接通过require引入即可使用\nconst http = require('http'); \n\n//搭建最最最简单的服务\nhttp.createServer(function (request, response) {\n    // request response为参数，可以任意起名字\n    console.log('终于有人访问我了');\n    console.log(request.headers);\n}).listen(8081); //监听8081端口\n```\n\n##### 2. 在服务器环境下，在浏览器中访问localhost://8081:\n\n当在浏览器中访问localhost://8081 时，如果访问成功服务器就会有响应，就会执行createServer方法中的回调，request是一个大对象，包含所有请求信息，request.headers就为请求头对象\n\n查看命令终端中 console.log(request.headers)的信息如下:\n\n![命令行请求字段](http://ovqwwz784.bkt.clouddn.com/node_http_header.png)\n\n```\n{ \n    host: 'localhost:8081',\n    'connection': 'keep-alive',\n    'cache-control': 'max-age=0',\n    'upgrade-insecure-requests': '1',\n    'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) \nAppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',\n     accept: 'text/html, application/xhtml+xml, application/xml; q=0.9, image/webp, */*;q=0.8',\n     'accept-encoding': 'gzip, deflate, sdch, br',\n     'accept-language': 'zh-CN, zh; q=0.8, en; q=0.6' \n}\n```\n\n- **host**: 表示服务器的域名，也就是主机名称\n- **cache-control**: 表示通过设置不同指令来实现自己想要的缓存机制，\"max-age=0\" 表示缓存的最大周期，是一个时间段而非时间点,从访问服务器的时间开始算起，而请求头中还可以设置expires指令，值为时间戳，表示过期时间，是一个时间点，如果设置\"max-age\"指令的时候，就会自动忽略expires指令\n- **user-agent**: 翻译过来为用户代理，作用是让服务器能识别客户端的操作系统，浏览器类型版本等\n- **accept**: 这个要先了解一个概念，MIME类型，我的理解是客户端能识别不同文件类型的机制。accept请求头用来告知客户端可以处理的内容类型。'text/html'表示能处理文本类型为html,'image/*'表示能处理全部图片类型, 都是'父类型/子类型'这种格式\n- **accept-encoding**: 表示通知客户端能够理解的内容编码，一般为压缩算法\n- **accept-language**: 设置客户端可以理解的语言\n\n未完，不定时更新。。。\n\n由于能力有限，也刚开始记录和分享自己的学习的过程，希望各位大神们多多指点和补充。\n  ",
    "category_name": "http",
    "isSaved": "2",
    "date": new Date(1515143832857),
    "__v": 0
}, {
    "_id": "5a4f42dec4780dbc7f6b4f48",
    "article_id": "5a4f42d0c4780dbc7f6b4f47",
    "article_title": "js执行机制、事件循环、执行栈、执行环境(上下文)、作用域、作用域链、活动对象、变量对象的概念总结",
    "article_content": "最近去梳理了一下这些相关概念、对js执行机制也有了更深的认识、为此翻阅了《javaScript高级教程》、《javaScript权威指南》、《深入理解JavaScript系列》等书籍及相关博客，下面我会结合官方概念保证权威准确性、并结合自己的理解去讲解，如果大家发现哪地方不对，希望能多多指出，我自己也在反复理解这些概念。\n\n我先列出这基本经典书籍中的一些概念描述、让大家都有一个自己的最初认识，也方便后面讲解。然后接着往下看，会结合具体例子讲解概念，会更加清晰，看完之后保证你有一个新的认识。\n\n# 官方概念\n## 执行环境(执行上下文Execution Contexts):\n\n>执行环境定义了变量或函数有权访问的其他数据、决定了它们各自的行为。每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境 --《javaScript高级教程》\n\n## 作用域(Scope):\n\n>javaScript中没有块级作用域、取而代之的使用了函数作用域、即变量在声明它们的函数以及这个函数体嵌套的任意函数体内都是有定义的  --《javaScript权威指南》\n\n## 变量对象(Variable Object):\n\n>每一个执行环境都有一个与之关联的变量对象，是一个抽象的概念，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，单解析器在处理数据时会在后台使用它们。\n\n-------\n# 补充个人理解的概念\n下面我补充几个自己理解的概念:\n\n## [执行环境栈](https://baike.baidu.com/item/%E6%89%A7%E8%A1%8C%E6%A0%88/22105693?fr=aladdin):\n\n> 存放正在运行子程序(函数即是一个子程序)消息的一个区域，涉及到很多计算机系统知识，如CPU指令，读取内存等，暂时我简单理解为提供存储正在运行的子程序消息的一个区域，不同于对于数据结构中的栈内存。\n\n## 作用域链(Scope Chain):\n\n> 当函数创建时会创建一个包含其父函数变量、父函数的父函数的变量对象、直至全局变量对象的一个作用域链，这个作用域被保存在函数内部的[[scope]]属性中，由于函数本身即是对象，可以理解[[scope]]是后台可以访问的一个属性，不可再JavaScript代码中访问。当函数调用时，会创建一个自己的活动对象、作为变量对象，被推入到执行环境作用域链的最前端，此时这个[[scope]]属性相当于一个变量对象的集合，并有访问的优先级。作用域链并不保存实际的变量对象，它是一个指针，指向内存中的变量对象列表。\n\n*注释:* ECMA262-第5版规定在定义只有内部采用的特性(attribute)时，描述了属性(property)的各种特征。ECMA-262定义这些特性时为了实现javaScript引擎用的，因此在javaScript中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对方括号中，例如[[Enumerable]]。--《javaScript高级教程》\n\n# js事件循环(执行机制)\n\n简单说一下js事件循环，帮助我们理解下面的概念，可参考我另一篇文章[js事件循环(执行机制)](https://segmentfault.com/a/1190000011223209)\n\n# 变量对象(Variable Object, 缩写为VO)\n\n当浏览器第一次加载js脚本程序的时候, 默认进入全局执行环境, 此次的全局环境变量对象为window, 在代码中可以访问。\n\n如果环境是函数, 则将此活动对象做为当前上下文的变量对象(VO = AO), 此时变量对象是不可通过代码来访问的,下面主要对活动对象进行讲解。\n\n# 活动对象(Activation Object ,缩写为AO)\n\n当函数一调用，立刻创建当前上下文的活动对象, 通过arguments属性初始化，值为arguments对象(传入的实参集合,与形参无关,形参做为局部环境的局部变量被定义)\n\n```\nAO = {\n  arguments: <ArgO>\n};\n```\narguments对象有以下属性:\n\n- **length:** 真正传递参数的个数;\n- **callee:** 指向当前函数的引用,也就是被调用的函数;\n- **'类index':** 字符串类型的整数, 值就是arguments对象中对象下标的值,arguments对象应和数组加以区别, 它就是arguments对象,只是能和数组具有相同的length属性,和可以通过下标来访问值\n\n\n```\nfunction show (a, b, c) {\n    // 通过Object.prototype.toString.call()精准判断类型, 证明arguments不同于数组类型\n    var arr = [1, 2, 3];\n    console.log(Object.prototype.toString.call(arr)); // [object Array]\n\n    console.log(Object.prototype.toString.call(arguments)); // [object Arguments]\n\n    console.log(arguments.length) // 2  传递进来实参的个数\n\n    console.log(arguments.callee === show) // true 就是被调用的函数show自身\n\n    //参数共享\n\n    console.log(a === arguments[0]) // true\n\n    a = 15;\n\n    console.log(arguments[0]) // 15\n\n    arguments[0] = 25;\n\n    console.log(a)  // 25;\n\n    但是，对于没有传进来的参数c, 和arguments的第三个索引是不共享的\n\n    c = 25;\n\n    console.log(arguments[2]) // undefined\n\n    argument[2] = 35;\n\n    console.log(c) // 25\n\n}\n\nshow(10, 20);\n```\n\n接着往下走,这才是关键的地方,执行环境的代码被分成两个阶段来处理：\n\n1. 进入执行环境\n2. 执行函数的代码\n\n## 进入执行环境\n\n前面说过,函数如果被调用, 进入执行环境(上下文)，并立即创建活动对象, 通过arguments属性初始化, 与此同时会扫描执行环境中的所有形参、所有函数声明、所有变量声明, 添加到活动对象(AO)中, 并确定this的值，然后会开始执行代码。\n\n**在进入执行环境这个阶段:**\n\n**所有形参声明:**\n\n>形参名称作为活动对象属性被创建, 如果传递实参, 值就为实参值, 如果没有传递参数, 值就为undefined\n\n**所有函数声明:**\n\n>函数名称作为活动对象的属性被创建，值是一个指针在内存中, 指向这个函数,如果变量对象已经存在相同名称的属性, 则完全替换。\n\n**所有变量声明:**\n\n>所有变量名称作为活动对象的属性被创建, 值为undefined,但是和函数声明不同的是, 如果变量名称跟已经存在的属性(形式参数和函数)相同、则不会覆盖\n\n\n```\nfunction foo(a, b) {\n    var c = 10;\n    function d() {\n        console.log('d');\n    }\n    var e = function () {\n        console.log('e');\n    };\n    (function f() {})\n    if (true) {\n        var g = 20;\n    } else {\n        var h = 30;\n    }\n}\n\nfoo(10);\n```\n\n此时在进入foo函数执行上下文时,AO为:\n\n```\nAO(foo) = {\n    arguments: {\n        0: 10,\n        length: 1\n    },\n    a: 10,\n    b: undefined,\n    c: fundefined,\n    d: '指向d函数的指针',\n    e: undefined,\n    g: undefined,\n    h: undefined  // 虽然else中的代码永远不会执行,但是h仍然是活动对象中的属性\n}\n\n```\n\n**这个例子做如下几点说明:**\n\n1. 关于函数,只会创建函数声明作为活动对象的属性, 而f函数作为函数表达式并不会出现在活动对象(AO)中\n\n2. e虽然值是一个函数, 但是作为变量属性被活动对象创建\n\n## 代码执行阶段\n\n在进入执行上下文阶段，活动对象拥有了属性，但是很多属性值为undefined, 到代码直接阶段就开始为这些属性赋值了\n\n**还是上面的代码例子, 此时活动对象如下:**\n\nAO(foo) = {\n    arguments: {\n        0: 10,\n        length: 1\n    },\n    a: 10,\n    b: undefined,\n    c: 10, // 赋值为undefined\n    d: '指向d函数的指针',\n    e: '指向e函数的指针' // 作为变量被保存在内存中\n    g: 20,\n    h: undefined  // 声明h变量,但是没有赋值\n}\n\n```\n变量对象包括:{arguments对象+函数形参+内部变量＋函数声明(但不包含表达式)}\n```\n\n这时这个活动对象, 即作为当前执行环境的变量对象会被推到此执行环境作用域链的最前端, 另外别忘记了当前上线问指针,假定执行环境为一个对象,则整个执行环境可以访问到的属性如下:\n\n```\nfooExecutionContext = {\n    scopeChain(作用域链):  AO(foo的活动对象)+所有父执行环境的活动对象,\n    AO(foo的变量对象): {\n        arguments: {\n            0: 10,\n            length: 1\n        },\n        a: 10,\n        b: undefined,\n        c: 10, // 赋值为undefined\n        d: '指向d函数的指针',\n        e: '指向e函数的指针',\n        g: 20,\n        h: undefined\n    },\n    this: 当前执行环境的上下文指针\n}\n```\n\n下面的例子为了说明一下变量声明的顺序及变量同名不会影响函数声明\n\n```\nconsole.log(foo); //  foo的函数体\nvar foo = 10;\nconsole.log(foo) // 10\nfunction foo() {};\nfoo = 20;\nconsole.log(foo); // 20\n\n```\n\n在代码执行之前, 就会读取函数声明,变量声明的顺序在函数声明和形参声明之后, 整个流程如下:\n\n进入执行环境阶段:\n\n```\n1. var VO = {}\n2. VO[foo] = 'foo函数指针'\n3. 扫描到var foo = 10，但是foo做为function已经声明，所以变量声明不会影响同名的函数声明，如果代码中没有foo函数声明的话,则foo为undefined\n```\n\n代码执行阶段:\n\n```\n1. VO[foo] = 10;\n2. VO[foo] = 20;\n```\n\n解析代码完成。\n\n# 总结个人理解的概念\n\n写了这么多,终于写完了,最后,想说一下我对这几个概念的理解:\n\n## 执行环境(执行上下文):\n\n>作为一段可执行的程序,我抽象把它理解成一个任务,当函数被调用,立刻创建当前执行环境,并被推入到执行栈中\n\n## 作用域:\n\n> 一个抽象的概念, 对当前执行环境所有数据的访问权限\n\n## 变量对象:\n\n> 一个抽象的概念，与执行环境相对象，全局执行环境的变量对象为window,可访问。在函数环境中，函数调用后创建的活动对象即作为当前执行环境的变量对象, 此时从引用的角度看，二者是一个东东。\n\n## 活动对象:\n\n> 作为具体概念存在，在全局执行环境不存在这个概念，全局变量对象的变量对象指向window，而且并不存在arguments属性\n\n整篇文章基本上这就是我能理解到的程度了， 很多概念查找很多书籍并加入自己的理解，在后续理解逐渐加深后,也会更新本文， 希望能帮到对此也迷惑的人，如果有理解不对的地方，希望大家多多给出指导意见,谢谢。\n  ",
    "category_name": "javaScript",
    "isSaved": "2",
    "date": new Date(1515143902502),
    "__v": 0
}, {
    "_id": "5a4f4331c4780dbc7f6b4f4c",
    "article_id": "5a4f431dc4780dbc7f6b4f4b",
    "article_title": "js中的Object.defineProperty()和defineProperties()",
    "article_content": ">ECMAS-262第5版在定义只有内部采用的特性时，提供了描述了属性特征的几种属性。ECMAScript对象中目前存在的属性描述符主要有两种，数据描述符(数据属性)和存取描述符(访问器属性)，数据描述符是一个拥有可写或不可写值的属性。存取描述符是由一对 getter-setter 函数功能来描述的属性。\n\nObject的**defineProperty**和**defineProperties**这两个方法在js中的重要性十分重要，主要功能就是用来**定义或修改这些内部属性**,与之相对应的**getOwnPropertyDescriptor**和**getOwnPropertyDescriptors**就是获取这行内部属性的描述。\n\n下面文章我先介绍数据描述符和存取描述符的属性代表的含义，然后简单介绍以上四个方法的基本功能，这些如果了解可直接跳过，最后我会举例扩展及说明各内部属性在各种场景下产生的实际效果，那才是这篇文章的核心内容。本文章关于概念性的描述还是会尽量使用《javaScript高级教程》、MDN网站等概念，保证准确和易于大家理解，讲解部分则结合个人理解和举例说明。\n\n# 数据(数据描述符)属性\n\n数据属性有4个描述内部属性的特性\n\n## [[Configurable]]\n表示能否通过[delete](https://segmentfault.com/a/1190000010574280)删除此属性，能否修改属性的特性，或能否修改把属性修改为访问器属性，如果直接使用字面量定义对象，默认值为true\n\n## [[Enumerable]] \n表示该属性是否可枚举，即是否通过for-in循环或Object.keys()返回属性，如果直接使用字面量定义对象，默认值为true\n## [[Writable]]\n能否修改属性的值，如果直接使用字面量定义对象，默认值为true\n## [[Value]]\n\n该属性对应的值，默认为undefined\n\n#访问器(存取描述符)属性\n访问器属性也有4个描述内部属性的特性\n## [[Configurable]]\n和数据属性的[[Configurable]]一样，表示能否通过delete删除此属性，能否修改属性的特性，或能否修改把属性修改为访问器属性，如果直接使用字面量定义对象，默认值为true\n\n## [[Enumerable]] \n和数据属性的[[Configurable]]一样，表示该属性是否可枚举，即是否通过for-in循环或Object.keys()返回属性，如果直接使用字面量定义对象，默认值为true\n\n## [[Get]]\n一个给属性提供 getter 的方法(访问对象属性时调用的函数,返回值就是当前属性的值)，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined\n\n## [[Set]]\n\n一个给属性提供 setter 的方法(给对象属性设置值时调用的函数)，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined\n\n# 创建/修改/获取属性的方法\n## Object.defineProperty()\n**功能:**\n方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined\n```\n语法: Object.defineProperty(obj, prop, descriptor)\n```\n**obj:** 需要被操作的目标对象\n**prop:** 目标对象需要定义或修改的属性的名称\n**descriptor:** 将被定义或修改的属性的描述符\n```\nvar obj = new Object();\n\nObject.defineProperty(obj, 'name', {\n    configurable: false,\n    writable: true,\n    enumerable: true,\n    value: '张三'\n})\n\nconsole.log(obj.name)  //张三\n```\n## Object.defineProperties()\n**功能:**\n方法直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。\n```\n语法: Object.defineProperties(obj, props)\n```\n**obj:** 将要被添加属性或修改属性的对象\n**props:** 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置\n\n```\nvar obj = new Object();\nObject.defineProperties(obj, {\n    name: {\n        value: '张三',\n        configurable: false,\n        writable: true,\n        enumerable: true\n    },\n    age: {\n        value: 18,\n        configurable: true\n    }\n})\n\nconsole.log(obj.name, obj.age) // 张三, 18\n```\n\n## Object.getOwnPropertyDescriptor()\n**功能:**\n该方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）\n```\n语法: Object.getOwnPropertyDescriptor(obj, prop)\n```\n\n**obj:** 需要查找的目标对象\n**prop:** 目标对象内属性名称\n\n```\nvar person = {\n    name: '张三',\n    age: 18\n}\n\nvar desc = Object.getOwnPropertyDescriptor(person, 'name'); \nconsole.log(desc)  结果如下\n// {\n//     configurable: true,\n//     enumerable: true,\n//     writable: true,\n//     value: \"张三\"\n// }\n\n```\n\n## Object. getOwnPropertyDescriptors()\n**功能:**\n所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。\n```\n语法: Object.getOwnPropertyDescriptors(obj)\n```\n**obj:** 需要查找的目标对象\n\n```\nvar person = {\n    name: '张三',\n    age: 18\n}\nvar desc = Object.getOwnPropertyDescriptors(person, 'name');\nconsole.log(desc) // 结果如下图\n\n```\n\n![console结果](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-21%20%E4%B8%8A%E5%8D%8810.40.34.png)\n\n#各种场景下描述符属性的的扩展示例讲解\n\n## configrubale\n\n如果设置configrubale属性为false，则不可使用delete操作符(在严格模式下抛出错误), 修改所有内部属性值会抛出错误,在《javaScript高级教程中》说只可以改变writable的值，现在改变writable的值也会抛出错误\n### 在对象中添加一个数据描述符属性\n```\nvar person = {};\n\nObject.defineProperty(person, 'name', {\n    configurable: false,\n    value: 'John'\n}) ;\n\ndelete person.name   // 严格模式下抛出错误\n\nconsole.log(person.name)  // 'John'  没有删除\n\nObject.defineProperty(person, 'name', {\n    configurable: true  //报错\n});\n\nObject.defineProperty(person, 'name', {\n    enumerable: 2  //报错\n});\n\nObject.defineProperty(person, 'name', {\n    writable: true  //报错\n});\n\nObject.defineProperty(person, 'name', {\n    value: 2  //报错\n});\n```\n**注意:**\n以上是最开始定义属性描述符时,writabl默认为false,才会出现上述效果,如果writable定义为true, 则可以修改[[writable]]和[[value]]属性值,修改另外两个属性值报错\n\n```\nvar obj = {};\n\nObject.defineProperty(obj, 'a', {\n    configurable: false,\n    writable: true,\n    value: 1\n});\n\nObject.defineProperty(obj, 'a', {\n    // configurable: true, //报错\n    // enumerable: true,  //报错\n    writable: false,\n    value: 2\n});\nvar d = Object.getOwnPropertyDescriptor(obj, 'a')\nconsole.log(d);\n// {\n//     value: 2, \n//     writable: false, \n// }\n```\n\n### 在对象中添加存取描述符属性\n\n```\nvar obj = {};\nvar aValue; //如果不初始化变量, 不给下面的a属性设置值,直接读取会报错aValue is not defined\nvar b;\nObject.defineProperty(obj, 'a', {\n    configurable : true,\n    enumerable : true,\n    get: function() {\n        return aValue\n    },\n    set: function(newValue) {\n        aValue = newValue;\n        b = newValue + 1\n    }\n})\nconsole.log(b) // undefined\nconsole.log(obj.a)  // undefined, 当读取属性值时，调用get方法,返回undefined\nobj.a = 2;  // 当设置属性值时,调用set方法,aValue为2\n\nconsole.log(obj.a) // 2  读取属性值,调用get方法,此时aValue为2\nconsole.log(b) // 3  再给obj.a赋值时,执行set方法,b的值被修改为2,额外说一句,vue中的计算属性就是利用setter来实现的\n```\n**注意:**\n***1.getter和setter可以不同时使用,但在严格模式下只其中一个,会抛出错误***\n***2.数据描述符与存取描述符不可混用,会抛出错误***\n```\nvar obj = {};\nObject.defineProperty(obj, 'a', {\n    value: 'a1',\n    get: function() {\n       return 'a2'\n    }    \n});\n```\n\n***3.全局环境下:***\n```\nvar a = 1;  // a属于window, 相当于window.a\n```\n让我们来看看a的描述符属性\n```\nvar d = Object.getOwnPropertyDescriptor(window, 'a');\nconsole.log(d)\n// {\n//     configurable: false,\n//     value: 1,\n//     writable: true,\n//     enumerable: true\n// }\n```\n在来看一下另一种不适用var声明的方式初始化a变量\n\n```\na = 1; //a相当于window的一个属性, window.a\n```\n再来看看此时a的描述符属性\n```\nvar d = Object.getOwnPropertyDescriptor(window, 'a');\nconsole.log(d)\n// {\n//     configurable: true,   // 此时configurable属性值为true\n//     value: 1,\n//     writable: true,\n//     enumerable: true\n// }\n```\n**注意:**\n\n只有使用var, let等操作符才是定义变量，而不使用var，直接a=1;,这样a的含义为window的一个属性，并不是我们所说的变量的概念。使用 var定义的任何变量，其configurable属性值都为false,定义对象也是一样\n\n```\nvar b = {\n    name: 'bbb'\n}\nvar d = Object.getOwnPropertyDescriptor(window, 'b');\nconsole.log(d)\n// {\n//     configurable: false\n//     value: 1,\n//     writable: true,\n//     enumerable: true\n// }\n```\n但是这里需要说明的一点是,使用字面量定义的对象,该对象内部的属性的数据描述符属性都为true\n```\nvar b = {\n    name: 'bbb'\n}\nvar d = Object.getOwnPropertyDescriptor(b, 'name');\nconsole.log(d)\n// {\n//     configurable: true\n//     writable: true,\n//     enumerable: true\n//     value: 'bbb'\n// }\n```\n## Writable\n\n当writable为false(并且configrubale为true),[[value]]可以通过defineeProperty修改, 但不能直接赋值修改\n```\nvar obj = {};\n\nObject.defineProperty(obj, 'a', {\n    configurable: true,\n    enumerable: false,\n    writable: false,\n    value: 1\n});\n\nObject.defineProperty(obj, 'a', {\n    configurable: false,\n    enumerable: true,\n    writable: false ,\n    value: 2\n});\nvar d = Object.getOwnPropertyDescriptor(obj, 'a')\n\nconsole.log(d); // 结果如下\n// {\n//     value: 2, \n//     writable: false, \n//     enumerable: true, \n//     configurable: false\n// }\n\n\n但是如果直接复制修改\nvar obj = {}\n\nObject.defineProperty(obj, 'a', {\n    configurable: true,\n    enumerable: false,\n    writable: false,\n    value: 1\n});\no.a=2;\nvar d = Object.getOwnPropertyDescriptor(obj, 'a')\n\nconsole.log(d); // 结果如下\n\n// {\n//     value: 1,  // 没有做出修改\n//     writable: false, \n//     enumerable: true, \n//     configurable: false\n// }\n```\n\n## Enumerable\n\n直接上例子\n\n```\nvar obj = {};\nObject.defineProperties(obj, {\n    a: {\n        value: 1,\n        enumerable: false\n    }, \n    b: {\n        value: 2,\n        enumerable: true\n    },\n    c: {\n        value: 3,\n        enumerable: false\n    }\n})\n\nobj.d = 4;\n\n//等同于\n\n//Object.defineProperty(obj, 'd', {\n//    configurable: true,\n//    enumerable: true,\n//    writable: true,\n//    value: 4\n//})\n\nfor(var key in obj) {\n    console.log(key);  \n    // 打印一次b, 一次d, a和c属性enumerable为false，不可被枚举\n} \n\nvar arr = Object.keys(obj);\nconsole.log(arr);  // ['b', 'd']\n\n```\n## get和set\n\n### 简易的数据双向绑定\n\n在线demo地址: http://www.sunzhaoye.com/demo/index.html\n\nhtml代码:\n```\n<body>\n    <p>\n        input1=><input type=\"text\" id=\"input1\">\n    </p>\n    <p>\n        input2=>\n        <input type=\"text\" id=\"input2\">\n    </p>\n    <div>\n        我每次比input1的值加1=>\n        <span id=\"span\"></span>\n    </div>\n</body>\n```\njs代码:\n```\nvar oInput1 = document.getElementById('input1');\nvar oInput2 = document.getElementById('input2');\nvar oSpan = document.getElementById('span');\nvar obj = {};\nObject.defineProperties(obj, {\n    val1: {\n        configurable: true,\n        get: function() {\n            oInput1.value = 0;\n            oInput2.value = 0;\n            oSpan.innerHTML = 0;\n            return 0\n        },\n        set: function(newValue) {\n            oInput2.value = newValue;\n            oSpan.innerHTML = Number(newValue) ? Number(newValue) : 0\n        }\n    },\n    val2: {\n        configurable: true,\n        get: function() {\n            oInput1.value = 0;\n            oInput2.value = 0;\n            oSpan.innerHTML = 0;\n            return 0\n        },\n        set: function(newValue) {\n            oInput1.value = newValue;\n            oSpan.innerHTML = Number(newValue)+1;\n        }\n    }\n})\noInput1.value = obj.val1;\noInput1.addEventListener('keyup', function() {\n    obj.val1 = oInput1.value;\n}, false)\noInput2.addEventListener('keyup', function() {\n    obj.val2 = oInput2.value;\n}, false)\n```\n# 总结\n终于到了最后了,就不具体梳理总结了。虽然我们在开过过程中不怎么使用几种方法，但理解之后对于我们理解js中对象有很大帮助,对后续进步也很有帮助,比如vue的实现原理等。个人能力有限,还希望大家发现问题后能多多指点,共同进步。\n  ",
    "category_name": "javaScript",
    "isSaved": "2",
    "date": new Date(1515143985539),
    "__v": 0
}, {
    "_id": "5a4f435ac4780dbc7f6b4f4e",
    "article_id": "5a4f434fc4780dbc7f6b4f4d",
    "article_title": "js简易版的vue数据双向绑定",
    "article_content": "# 简易版的vue数据双向绑定\n\n在线demo地址: http://www.sunzhaoye.com/demo/index.html\n\nhtml代码:\n```\n<body>\n    <p>\n        input1=><input type=\"text\" id=\"input1\">\n    </p>\n    <p>\n        input2=>\n        <input type=\"text\" id=\"input2\">\n    </p>\n    <div>\n        我每次比input1的值加1=>\n        <span id=\"span\"></span>\n    </div>\n</body>\n```\njs代码:\n```\nvar oInput1 = document.getElementById('input1');\nvar oInput2 = document.getElementById('input2');\nvar oSpan = document.getElementById('span');\nvar obj = {};\nObject.defineProperties(obj, {\n    val1: {\n        configurable: true,\n        get: function() {\n            return oInput1.value;\n        },\n        set: function(newValue) {\n            // 过滤输入框的首位空格\n            newValue = newValue.replace(/(^\\s*)|(\\s*$)/g, \"\");\n            oInput2.value = newValue;\n            // 仅限输入数字，如果输入非Number类型, 则Number(newValue)为NaN了,只是为了说明计算属性\n            // newValue为空时, Number(newValue) = 0\n            // 输入0时, 是typeof newValue为String,为'0'\n            // 以下代码是如果newValue为空, 判断条件为true, 如果newValue为'0',进入else \n            oSpan.innerHTML = Number(newValue) === 0 && newValue !=='0'  ? '' : Number(newValue)+1\n        }\n    },\n    val2: {\n        configurable: true,\n        get: function() {\n            return oInput2.value;\n        },\n        set: function(newValue) {\n            // 过滤输入框的首位空格\n            newValue = newValue.replace(/(^\\s*)|(\\s*$)/g, \"\");\n            oInput1.value = newValue;\n            oSpan.innerHTML = Number(newValue) === 0 && newValue !=='0'  ? '' : Number(newValue)+1\n        }\n    }\n});\noInput1.value = obj.val1;\noInput1.addEventListener('keyup', function() {\n    obj.val1 = oInput1.value;   // val1赋值之后进入val1的setter\n}, false);\noInput2.addEventListener('keyup', function() {\n    obj.val2 = oInput2.value;   // val2赋值之后进入val2的setter\n}, false);\n```\n  ",
    "category_name": "vue",
    "isSaved": "2",
    "date": new Date(1515144026623),
    "__v": 0
}, {
    "_id": "5a4f437cc4780dbc7f6b4f50",
    "article_id": "5a4f436dc4780dbc7f6b4f4f",
    "article_title": "js中的面向对象、原型、原型链、继承",
    "article_content": "# 本文主要内容\n**(本文较长,请耐心阅读,必有收获):**\n\n* 什么是对象\n* 创建对象的几种方式\n    * 使用构造函数创建\n    * 字面量创建\n    * 工厂模式\n    * 构造模式\n    * 原型模式\n        * 原型\n    * 组合使用构造函数模式和原型模式\n* 继承\n    * 原型链\n    * 属性查找机制\n    * 经典继承\n* 个人扩展补充\n    * hasOwnProperty()\n    * 重写原型对象\n    * 显式prototype和隐式[[Prototype]]属性\n\n# 什么是对象\n\n直接上《JavaScript高级教程》的截图\n\n![对象](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-23%20%E4%B8%8A%E5%8D%8810.03.29.png)\n\n**补充:**\njs中说一切都是对象,是不完全的,在js中6种数据类型(Undefined,Null,Number,Boolean,String,Object)中,前五种是基本数据类型,是原始值类型,这些值是在底层实现的,他们不是object，所以没有原型，没有构造函数,所以并不是像创建对象那样通过构造函数创建的实例。关于对象属性类型的介绍就不介绍了,可以看我上一篇文章[Object.defineProperty()和defineProperties()](https://segmentfault.com/a/1190000011294519)\n\n# 创建对象\n\n## 1.使用构造函数创建\n```\nvar obj = new Object();\n```\n## 2.字面量创建\n```\nvar obj = {};\n```\n## 3.工厂模式\n\n如果使用构造函数和字面量创建很多对象,每个对象本身又有很多相同的属性和方法的话,就会产生大量重复代码,每个对象添加属性都需要重新写一次。如两个对象都需要添加name、age属性及showName方法:\n```\nvar p1 = new Object();\np1.name = '张三'\np1.age = '16',\np1.showName = function() {\n    return this.name\n}\n\nvar p2 = new Object();\np2.name = '李四'\np2.age = '18',\np2.showName = function() {\n    return this.name\n}\n```\n为了解决这个问题,人们采用了工厂模式,抽象了创建对象的过程,采用函数封装以特定接口(相同的属性和方法)创建对象的过程。\n\n```\nfunction createPerson(name, age) {\n    var obj = new Object();\n    obj.name = name;\n    obj.age = age;\n    obj.showName = function () {\n        return  this.name;\n    };\n    return obj;\n}\n\nvar p1 = createPerson('张三', 16);\nvar p2 = createPerson('李四', 18);\n```\n## 4.构造模式\n虽然工厂模式解决了创建多个对象的多个相同属性问题,却无法判定对象的具体类型,因为都是Object,无法识别是Array、或是Function等类型,这个时候构造函数模式出现了。\n\njs中提供了像Object,Array,Function等这样的原生的构造函数,同时也可以创建自定义的构造函数,构造函数是一个函数，用来创建并初始化新创建的对象。将工厂模式的例子用构造函数可以重写为: \n\n```\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n    this.showName = function() {\n        console.log(this.name);\n    }\n}\n\nvar p1 = new Person('张三', '16');\nvar p2 = new Person('李四', '18');\n```\n用Person代替了工厂模式的createPerson函数,而且函数名首字母P大写,这是因为按照惯例,构造函数首字母应该大写,而作为非构造函数的函数首字母小写。另外可以注意到构造函数内部的特点: \n1. 没有显示创建对象\n2. 直接在this上添加属性和方法\n3. 没有return \n\n另外,还使用了new操作, 要创建一个实例,必须使用new操作符,使用new操作符调用构造函数,在调用构造函数的时候经历了如下几个阶段:\n\n1. 创建一个对象\n2. 把创建的对象赋值给this\n3. 执行函数中的代码, 即把属性和方法添加到赋值之后的this\n4. 返回新对象\n\n用**伪代码**来说明上述new Person()的过程如下: \n\n```\n// 使用new操作符时,会激活函数本身的内部属性[[Construct]],负责分配内存\nPerson.[[Construct]](initialParameters):\n\n// 使用原生构造函数创建实例\nvar Obj = new NativeObject() //NativeObject为原生构造函数,如Object、Array、Function等\n\n// 给创建的实例添加[[Class]]内部属性,字符串对象的一种表示, 如[Object Array]\n// Object.prototype.toString.call(obj)返回值指向的就是[[Class]]这个内部属性\nObj.[[Class]] = Object/Array/Function;\n\n// 给创建的实例添加[[Prototype]]内部属性,指向构造函数的prototype\nO.[[Prototype]] = Person.prototype;\n\n// 调用构造函数内部属性[Call],将Person执行上下文中this设置为内部创建的对象Obj\n\nResult = Person.[[Call]](initialParameters); \n// this = Obj;\n// result是如果构造函数内部如果存在返回值的话,调用[[call]]时作为返回值,一般为Object类型\n// 调用Person.[[call]]时,执行Person中的代码,给this对象添加属性和方法\nthis.name = name;\nthis.age = age;\nthis.showName = function() {\n    console.log(this.name);\n};\n\n//如果Person.[[call]]的返回值Result为Object类型\nreturn Result\n// 否则\nreturn Obj;\n```\n补充,贴出ECMAScript 5.1版本标准中[[Construct]]的规范\n\n![construct](http://ovqwwz784.bkt.clouddn.com/Construct.png)\n\n\n构造函数虽然解决了实例多个同名属性重复添加的问题,但是也存在每个实例的方法都需要重新创建一遍,因为每个方法都是Function的不同实例,看下面这段代码就明白了:\n```\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n    this.showName = new Function(\"console.log(this.name);\");\n}\n\nvar p1 = new Person('张三', '16');\nvar p2 = new Person('李四', '18');\nconsole.log(p1.showName === p2.showName); //false \n```\n这个问题可以用以下办法来解决,把showName变成全局函数\n```\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n    this.showName = showName;\n}\nfunction showName() {\n    console.log(this.name)\n}\n```\n但是这样如果对象需要添加很多方法就会产生很多全局函数,这些问题可以通过原型模式来解决\n\n## 5.原型模式\n\n### 什么是原型\n\n当每一个函数创建时,都会给函数设置一个prototype(原型)属性,这个属性是一个指针,指向一个对象,这个对象包含所有实例共享的属性和方法,在默认情况下,都会为prototype对象添加一个constructor属性,指向该函数。\n\n```\nPerson.prototype.constructor = Person;\n```\n\n原型模式就是不必在构造函数中定义实例的属性和方法,而是将属性和方法都添加到原型对象中。创建自定义构造函数,其原型对象只会默认取得constructor属性,其他的属性和方法都是从Object继承来的。当使用构造函数创建一个实例之后,会给实例添加内部属性**[[prototype]]**,这个属性是一个指针,指向构造函数的prototype(原型)对象,由于是内部属性,无法通过脚本获取,但是在一些Chrome、Firefox、Safari等浏览器中在每个对象身上支持一个__proto__属性,指向的就是构造函数的原型对象。另外可以通过**isProtoTypeOf()**来判断创建的实例是否有指向某构造函数的指针,如果存在,返回true,如果不存在,返回false。\n\n```\nfunction Person() {\n\n}\nPerson.prototype.name = '张三';\nPerson.prototype.friends = ['张三', '李四'];\nPerson.prototype.showName = function() {\n    console.log(this.name);\n}\nvar p1 = new Person();\nvar p2 = new Person()\nconsole.log(p1.__proto__ === Person.prototype)  // true\nconsole.log(Person.prototype.isPrototypeOf(p1))  // true\n```\n\n在ECMA5中增加了一个方法**Object.getPrototypeOf(params)**,返回值就是创建对象的原型对象\n\n```\nconsole.log(Object.getPrototypeOf(p1) === Person.prototype); // true\nconsole.log(Object.getPrototypeOf(p1).name);  //张三\n```\n\n原型模式虽然解决了方法共享的问题,但是对于实例共享来说是个比较大的问题,因为每个实例都需要有描述自己本身特性的专有属性,还是上面的代码:\n\n```\n    console.log(p1.name)  // '张三'\n    console.log(p2.name)  // '张三'\n```\n\n另外对于属性是引用类型的值来说缺点就更明显了,如果执行下面这段代码:\n\n```\np1.friends.push('王五');\nconsole.log(p1.priends);  //['张三', '李四', '王五']\nconsole.log(p2.priends);  //['张三', '李四', '王五']\n```\n为了解决原型模式的问题,人们采用了原型和构造组合模式,使用构造函数定义实例,使用原型模式共享方法。\n\n## 6组合使用构造函数模式和原型模式\n直接上代码:\n\n```\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n    this.friends = ['张三', '李四']; // this.friends = new Array('张三', '李四')\n}\n\nPerson.prototype.showName = function() {\n    console.log(this.name);\n};\n\nvar p1 = new Person('John');\nvar p2 = new Person('Alice');\np1.friends.push('王五');\nconsole.log(p1.friends); // ['张三', '李四', '王五'];\nconsole.log(p2.friends); // ['张三', '李四'];\n// 因为这时候每个实例创建的时候的friends属性的指针地址不同,所以操作p1的friends属性并不会对p2的friends属性有影响\n\nconsole.log(p1.showName === p2.showName)  // true  都指向了Person.prototype中的showName\n\n```\n\n这种构造函数模式和原型模式组合使用,基本上可以说是js中面向对象开发的一种默认模式,介绍了以上这几种常用创建对象的方式, 还有其他不常用的模式就不介绍了,接下来想说的是js中比较重要的继承。\n\n# 继承\n\n## 什么是原型链\nECMA中继承的主要方法就是通过原型链,主要是一个原型对象等于另一个类型的实例,由于实例内部含有一个指向构造函数的指针,这时候相当于重写了该原型对象,此时该原型对象就包含了一个指向另一个原型的指针,假如另一个原型又是另一个类型的实例,这样就形成了原型链的概念,原型链最底层为Object.prototype.__proto__,为null。\n\n## 属性查找机制\n\njs中实例属性的查找,是按照原型链进行查找,先找实例本身有没有这个属性,如果没有就去查找查找实例的原型对象,也就是[[prototype]]属性指向的原型对象,一直查到Object.prototype,如果还是没有该属性,返回undefined。所有函数的默认原型都是Object实例。\n\n```\nfunction Parent() {\n    this.surname = '张';\n    this.name = '张三';\n    this.like = ['apple', 'banana'];\n}\nvar par = new Parent()\nfunction Child() {\n    this.name = '张小三';\n}\nParent.prototype.showSurname = function() {\n    return this.surname\n}\n// 继承实现\n\nChild.prototype = new Parent();\n\nvar chi = new Child();\nconsole.log(chi.showSurname())  // 张\n\n```\n\n以上代码证明,此时Child实例已经可以访问到showSurname方法,这就是通过原型链继承Parent原型方法,剖析一下其过程:\n```\nChild.prototype = new Parent();\n```\n相当于重写了Child.prototype,指向了父实例par,同时也包含了父实例的[[prototype]]属性,此时\n\n```\nconsole.log(Child.prototype.__proto__ === par.__proto__); // true\nconsole.log(Child.prototype.__proto__ === Parent.prototype); // true\n```\n执行chi.showSurname()时,根据属性查找机制:\n\n1. 先从实例chi本身查找,有没有showSurname,没有\n2. 继续查找chi的原型对象Child.prototype有没有showSurname,没有\n3. 继续查找Child.prototype的原型指针__proto__有没有showSurname,此时Child.prototype.__proto__的指针地址指向Parent.prototype,找到了,所以\n```\nconsole.log(chi.showSurname())  // 张\n```\n\n**补充:**\n所有函数默认继承Object:\n\n```\nfunction Person() {\n\n}\nconsole.log(Person.prototype.__proto__ === Object.prototype); // true\n```\n\n## 构造函数模式和原型模式组合继承\n只通过原型来实现继承,还存在一定问题,所以js中一般通过借用构造函数和原型组合的方式来实现继承,也称**经典继承**,还是继承那段代码,再贴过来把,方便阅读\n\n```\nfunction Parent() {\n    this.surname = '张';\n    this.name = '张三';\n    this.like = ['apple', 'banana'];\n}\nvar par = new Parent()\nfunction Child() {\n    this.name = '张小三';\n}\nParent.prototype.showSurname = function() {\n    return this.surname\n}\n// 继承实现\n\nChild.prototype = new Parent();\n\nvar chi1 = new Child();\nvar chi2 = new Child();\nconsole.log(chi.showSurname())  // 张\n\n// 主要看继承的属性\n\nconsole.log(chi.like)  //  ['apple', 'banana']\n这是因为Child.prototype指向父实例,当查找实例chi本身没有like属性,就去查找chi的原型对象Child.prototype,所以找到了\n\n```\n那么还存在什么问题呢,主要就是涉及到引用类型的属性时,引用类型数据的原始属性会被实例所共享,而实例本身的属性应该有实例自己的特性,还是以上代码\n```\nchi.like.push('orange');\nconsole.log(chi1.like);    // ['apple', 'banana', 'orange']\nconsole.log(chi2.like);    // ['apple', 'banana', 'orange']\n```\n所以构造函数和原型组合的经典继承出现了,也是本篇最重要的内容:\n\n**1.属性继承**\n\n在子构造函数内,使用apply()或call()方法调用父构造函数,并传递子构造函数的this\n\n**2.方法继承**\n\n使用上文提到的原型链继承,继承父构造器的方法\n\n上代码:\n```\nfunction Parent(name) {\n    this.name = name;\n    this.like = ['apple', 'banana'];\n}\nParent.prototype.showName = function() {\n\n    console.log(this.name);\n};\n\nfunction Child(name, age) {\n    // 继承属性\n    Parent.call(this, name);\n    // 添加自己的属性\n    this.age = age;\n}\nChild.prototype = new Parent();\n// 子构造函数添加自己的方法\nChild.prototype.showAge = function() {\n    console.log(this.age);\n};\n\nvar chi1 = new Child('张三', 16);\nvar chi2 = new Child('李四', 18);\n\nchi1.showName(); //张三\nchi1.showAge(); //16\nchi1.like.push('orange');\nconsole.log(chi1.like);  // ['apple', 'banana', 'orange']\nconsole.log(chi2.like);  // ['apple', 'banana']\n```\n在子构造函数Child中是用call()调用Parent(),在new Child()创建实例的时候,执行Parent中的代码,而此时的this已经被call()指向Child中的this,所以新建的子实例,就拥有了父实例的全部属性,这就是继承属性的原理。对chi1和chi2的like属性,是每个实例自己的属性,二者间不存在引用依赖关系,所以操作chi.like并不会对chi.like造成影响。方法继承,就是上文讲的到的原型链机制继承,另外可以给子构造函数添加自己的属性和方法。\n这就是经典继承,避免了但是使用构造函数或者单独使用原型链的缺陷,成为js中最常用的继承方式。\n\n# 个人扩展补充\n\n## hasOwnProperty()\n\n**用法: obj.hasOwnProperty(prop)**\n\n使用hasOwnProperty()方法可以判断访问的属性是原型属性还是实例属性,如果是实例属性返回true,否则返回false\n\n```\nfunction Person() {\n\n}\nPerson.prototype.name = '张三'\nvar p1 = new Person();\nvar p2 = new Person();\np1.name = '张三';\nconsole.log(p1.hasOwnProperty('name'))  //true\nconsole.log(p2.hasOwnProperty('name'))  //false\n```\n## 重写原型对象\n\n在实际开发中,如果原型对象有很多方法,往往我们可以使用字面量的形式,重写原型,但是需要手工指定constructor属性\n\n```\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\nvar p1 = new Person('张三', 16);\nPerson.prototype.showName = function() {\n    return this.name;\n}\nPerson.prototype.showAge = function() {\n    return this.age;\n}\n```\n如果构造函数的prototype方法很多,可以采用字面量方式定义\n\n```\nPerson.prototype = {\n    constructor: Person,\n    showName: function() {\n        return this.name;\n    },\n    showAge: function() {\n        return this.age;\n    }\n}\n```\n注意这里面手动加了一个constructor属性指向Person构造函数,这是因为使用字面量重写原型对象,这个原型对象变成了一个Object的实例,原型对象本身已经不存在最初函数创建时初始化的constructor属性,这是原型对象的[[prototype]]指针指向了Object.prototype\n\n## 显式prototype和隐式[[Prototype]]属性\n\n```\nfunction Person() {\n\t\n}\n\nPerson.prototype.a = 10;\nvar p = new Person();\n\nconsole.log(p.a)  //10\n\nPerson.prototype = {\n\tconstructor: Person,\n    a: 20,\n    b: 30\n}\n\nconsole.log(p.a)  // 10\nconsole.log(p.b)  // undefined\n\n\nvar p2 = new Person();\nconsole.log(p2.a)  // 20\nconsole.log(p2.b)  // 30\n```\n\n因此，有的文章说“动态修改原型将影响所有的对象都会拥有新的原型”是错误的，新原型仅仅在原型修改以后的新创建对象上生效。\n\n这里的主要规则是：对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式prototype引用，对象创建以后，只能对原型的属性进行添加或修改。\n\n以上就是我梳理出来的js中面向对象部分的相关概念和理解,依旧主要参考《JavaScript高教程》和[《深入理解JavaScript系列》](http://www.lai18.com/content/425668.html)文章,另外翻看了[ECMAScript5.1中文版](http://lzw.me/pages/ecmascript/#240)。本人对引用书中的概念和相关知识,为保证文章不误导大家,并不是拿来主义,希望本文能对大家有帮助,也希望大家多多指教。\n  ",
    "category_name": "javaScript",
    "isSaved": "2",
    "date": new Date(1515144060070),
    "__v": 0
}, {
    "_id": "5a4f43ccc4780dbc7f6b4f52",
    "article_id": "5a4f43bdc4780dbc7f6b4f51",
    "article_title": "js中的正则表达式",
    "article_content": "正则在平时工作中用的非常多, 最开始接触正则的时候感觉这个东东好难记啊,最近把正则的内容整理了一下,写成以下文章。\n\n先给大家介绍一个在线解析正则的网站,来帮助我们理解正则,特别是复杂的正则表达式,非常好用\n\nhttp://www.regexper.com\n\n比如/^@[a-zA-Z]\\d+@$/,解析之后图形帮助理解如下:\n\n![reg解析](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-14%20%E4%B8%8B%E5%8D%882.41.14.png)\n\n# 什么是正则\n\n正则表达式是用于匹配字符串中字符组合的模式。主要应用于正则对象的test和esec方法,以及字符串的search、split、match、replace中。\n\n# 创建正则\n\n## 字面量创建\n```\nvar reg = /pattern/flag;\n```\n\n在正则表达式保持不变,也就是不需要每次都创建一个新的正则对象的时候,使用字面量创建的正则性能更好\n\n每个正则表达式都可以带有一个或多个(也可以不带)表明正则表达式行为的标志\n\n![正则flag](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-14%20%E4%B8%8A%E5%8D%889.19.47.png)\n\n## 构造函数创建\n\n在js中提供了一个内置构造函数RegExp来创建一个正则对象\n```\nvar reg =  new RegExp(pattern [, flags]);\n```\n\n```\nvar reg = /[ab]c/g;\n// 等价于\nvar reg = new RegExp(\"[ab]c\", g);\n```\n\n# 正则表达式中的特殊字符\n\n## 元字符\n\n> 元字符是在正则表达式中有特殊含义的非字母字符,js中正则表达式元字符包括:\n\n? + *  ^ $ . | \\ ( ) [ ] { }\n\n因为这些字符在正则表达式中具有特殊含义,所以如果要想在字符串中匹配这些字符,就必须对它们进行转义.\n```\n// 匹配字符串中的ac或者bc\nvar reg = /[ab]c/;\n\n// 如果要匹配字符串的\"[ab]c\", 需要对[]进行转义\nvar reg = /\\[ab\\]c/;\n\n```\n\n**注意:**\n另外需要注意的是,由于使用构造函数创建正则,pattern参数必须为字符串,所有元字符如果需要在字符串中匹配这个字符,需要进行双重转义\n\n```\nvar reg = /\\[ab\\]c/g;\n\n如果使用构造函数创建正则表达式,应该写成:\n\nvar reg = new RegExp(\"\\\\[ab\\\\]c\", g);\n```\n\n## 字符集合\n\n我们可以使用[]来构建一个简单的类[xyz],类指符合某些特性的对象,是一个泛指,并不是指某个字符,表示匹配方括号的中任意字符,对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。\n```\nvar reg = /[abc]/g;\nvar reg2 = /[abc.]/g;  // 字符集合中的.\nvar reg3 = /[abc\\.]/g;  // 字符集合中转义的.\n\nvar str = 'a1b2c3';\nvar str2 = 'a1b2c3d.';\n\nvar res = str.replace(reg, 'X');\nvar res2 = str2.replace(reg2, 'X');\nvar res3 = str3.replace(reg3, 'X');\n\nconsole.log(res);  //  X1X2X3\nconsole.log(res2);  //  X1X2X3dX\nconsole.log(res3);  //  X1X2X3dX\n\n```\n\n## 字符集合取反\n\n一个反向字符集[\\^xyz], 它匹配任何没有包含在方括号中的字符\n```\nvar reg = /[^abc]/g;\nvar str = 'abcdefg';\nvar res = str.replace(reg, 'X');\nconsole.log(res);  //  abcXXXX\n```\n## 范围类 \n\n在字符集合中可以使用(-)来指定一个字符范围, 如[a-z],表示匹配从a到z的任意字符\n```\nvar reg = /[a-z]/g;\nvar str = 'a1b2c3d4e5F6';\nvar res = str.replace(reg, 'X');\nconsole.log(res); //  X1X2X3X4X5F6\n```\n在范围类[]中可以连写,如同时匹配大小写,[a-zA-Z]\n\n```\nvar reg = /[a-zA-Z]/g;\nvar str = 'a1b2c3d4e5F6';\nvar res = str.replace(reg, 'X');\nconsole.log(res); //  X1X2X3X4X5X6\n```\n## 预定义类\n\n正则表达式提供了预定义类,来匹配常见的字符类,不需要都通过字符集合去定义正则表达式\n\n| 字符     |  等价类 |  含义 |\n| -------- | --------| ---- |\n|.|[\\^\\\\n\\\\r]|匹配除回车符合换行符之外的任何单个字符|\n|\\\\d|[0-9]|数字字符|\n|\\\\D|[\\^0-9]|非数字字符|\n|\\\\s|[\\\\t\\\\n\\\\x0B\\\\f\\\\r]|空白符|\n|\\\\S|[\\^\\\\t\\\\n\\\\x0B\\\\f\\\\r]|非空白符|\n|\\\\w|[a-zA-Z_]|单词字符(字母、数字、下划线)|\n|\\\\W|[\\^a-zA-Z_]|非单词字符|\n\n## 边界\n正则还提供了边界匹配符\n\n| 字符     | 含义 |\n| -------- | ---- |\n|^|匹配输入的开始|\n|$|匹配输入的结尾|\n|\\\\b|单词边界|\n|\\\\B|非单词边界|\n\n```\n// ^的应用\nvar reg = /^@./g\nvar str = '@123abc@';\nvar res = str.replace(reg, 'X');\nconsole.log(res);  // X23abc\n\n// $的应用\nvar reg2 = /^.@$/g;\nvar str2 = '@123abc@';\nvar res2 = str2.replace(reg2, 'X');\nconsole.log(res2);  // 123abX\n\n// \\b的应用\nvar reg3 = /\\bis\\b/g;\nvar str3 = 'this is javaScript';\nvar res3 = str3.replace(reg3, 'X');\nconsole.log(res3); // this X javaScript\n```\n\n### 正则的m标志应用\n```\nvar reg = /^@./g;\nvar str = `@abc\n@123\n@XYZ\n`\nvar res = str.replace(reg, 'X');\n// 因为即使字符串看上去换行,本质上还是一些换行符,只有结尾和结束\nconsole.log(res);  //  Xbc\n                       @23\n                       @XYZ\n```\n当正则表达式使用m标志的时候,在一行文本末尾结束的时候,还会去匹配下一行是否存在与模式匹配的项,例子如下:\n```\nvar reg = /^@./gm;\nvar str = `@abc\n@123\n@XYZ\n`\nvar res = str.replace(reg, 'X');\nconsole.log(res);  //  Xbc\n                       X123\n                       XYZ\n```\n## 量词\n\n|字符|含义|\n| -- | -- |\n|?|匹配前面一个表达式0次或者1次(至多出现一次)|\n|+|匹配前面一个表达式1次或者多次(至少出现一次)|\n|*|匹配前一个表达式0次或多次(任意次)|\n|{n}|n是一个正整数，匹配了前面一个字符刚好发生了n次|\n|{n,m}|n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。|\n|{n,}|匹配前面字符n此或者更多次(至少出现n次|\n\n### 贪婪模式\n贪婪模式是让正则表达式尽可能多的匹配\n```\nvar reg = /\\d{2,5}/;\nvar str = '12345678';\nvar res = str.replace(reg, 'X');\nconsole.log(res); // X678\n```\n### 非贪婪模\n\n非贪婪模式是让正则表达式尽可能少的匹配,一旦匹配成功不在继续匹配,做法是在量词后面加上?即可\n\n```\nvar reg = /\\d{2,5}?/\nvar str = '12345678';\nvar res = str.replace(reg, 'X');\nconsole.log(res);  // X345678   \n```\n\n## 分组\n\n### 使用括号()进行分组\n量词不作用于紧挨着的某个字符,使用/(x)/匹配 'x',并且记住匹配项,括号被称为补货括号\n\n```\nvar reg = /([a-zA-Z]\\d)/g;\nvar str = 'a1bbc3D4efg';\nvar res = str.replace(reg, 'X');\nconsole.log(res);  // XbbXXefg\n```\n使用在线解析正则工具如下图:\n![res正则解析](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-14%20%E4%B8%8B%E5%8D%883.01.07.png)\n\n另外可以添加量词\n\n```\nvar reg = /(abc){3}/g;\nvar str = 'abcabcabcabc';\nvar res = str.replace(reg, 'X');\nconsole.log(res);  // Xabc\n```\n### 使用或' | '进行分组\n\n```\nvar reg = /apple|pear/g\nvar str = 'appleappleHpearpear';\nvar res = str.replace(reg, 'X');\nconsole.log(res);  // XXHXX\n\nvar reg2 = /appl(e|p)ear/g;\nvar str2 = 'appleearHapplpear'\nvar res2 = str2.replace(reg2, 'X');\nconsole.log(res2);  // XHX\n```\n在线解析上面代码的reg和reg2如下:\nreg:\n![reg](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-14%20%E4%B8%8B%E5%8D%883.18.46.png)\n\nreg2:\n![reg2](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-14%20%E4%B8%8B%E5%8D%883.19.05.png)\n\n### 捕获匹配到的分组内容\n\n在replace替换环节,可以使用$1、$2、$3...$n等捕获分匹配到的分组\n\n比如想把'25/12/2016'转换成'2016-12-25':\n\n```\nvar reg = /(\\d{2})\\/(\\d{2})\\/(\\d{4})/;\nvar str = '25/12/2016';\nvar res = str.replace(reg, '$3-$2-$1');\nconsole.log(res);  // 2016-12-25\n```\n### 忽略分组\n\n如果不希望捕获分组,只需要在分组内加上(?:)就可以\n\n```\nvar reg = /(?:\\d{2})\\/(\\d{2})\\/(\\d{4})/;\nvar str = '25/12/2016';\nvar res = str.replace(reg, '$3-$2-$1');\n\n此时$2为2016,$1为12,而$3捕获不到,按普通字符串显示\nconsole.log(res);  // $3-2016-12\n```\n## 正向肯定查找\nx(?=y)\n匹配x,并且x后必须跟着y,这就是正向肯定查找\n\n```\nvar reg = /\\w(?=\\d)/g;\nvar str = 'a1b2ccd4';\nvar res = str.replace(reg, 'X');\nconsole.log(res); // X1X2ccX4\n```\n\n## 正向否定查找\n匹配x,并且x后必须不跟着y,这就是正向否定查找\n\n```\nvar reg = /[a-z](?!\\d)/g;\nvar str = 'a1b2ccd4';\nvar res = str.replace(reg, 'X');\nconsole.log(res); // a1b2XXd4\n```\n# 正则对象属性和方法\n\n## 属性\n\n![正则对象属性](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-14%20%E4%B8%8B%E5%8D%884.03.10.png)\n\n属性皆为只读,不可修改\n\n```\nvar reg = /\\[abc\\]/;\nconsole.log(reg.ignoreCase) // false;\nconsole.log(reg.global) // false;\nconsole.log(reg.multiline) // false;\n\nreg.ignoreCase = true;\nreg.global = true;\nreg.multiline = true;\n\nconsole.log(reg.ignoreCase) // false;\nconsole.log(reg.global) // false;\nconsole.log(reg.multiline) // false;\n```\n还是以上代码看一下source属性\n```\nconsole.log(reg.source) //  \\[abc\\]\n```\n如果使用构造函数创建正则对象,再来看一下source属性\n```\nvar reg = new RegExp(\"\\\\[abc\\\\]\");  //需要对元字符进行双重转义\nconsole.log(reg.source);   // \\[abc\\]\n```\n通过以上对比可知,source属性是字面量形式创建正则对象所有的字符串\n## 方法\n\n### RegExp.prototype.test()\n\ntest() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。匹配到返回 true,否则返回false。\n\n**语法**\n```\nregexObj.test(str)\n```\n```\nvar reg = /\\w/;\nvar str = 'ab';\nconsole.log(reg.test(str));  // true\nconsole.log(reg.test(str));  // true\nconsole.log(reg.test(str));  // true\n```\n**注意**\n当正则表达式使用全局模式时,lastIndex属性会影响test()方法的返回值,看下面例子\n```\nvar reg = /\\w/g;\nvar str = 'ab';\nconsole.log(reg.test(str));  // true\nconsole.log(reg.test(str));  // true\nconsole.log(reg.test(str));  // false\nconsole.log(reg.test(str));  // true\n```\n为什么会出现这种现象呢,是因为正则表达式执行test方法时,每次都会把结果作用到操作的正则实例上,由于是全局匹配,第一次匹配到之后reg的lastIndex属性为1,继续匹配,此时从lastIndex的位置开始匹配,即从b开始,结果又匹配到,此时lastIndex属性为2，当继续匹配时,从2开始匹配,没有匹配到,此时返回false,lastIndex被重置为0,所以第4次执行console.log(reg.test(str))就会从新从0开始,所以返回值为true。结合while循环来说明一下:\n\n```\nvar reg = /\\w/g;\nvar str = 'ab';\nwhile(reg.test(str)){\n    console.log(reg.lastIndex);  // 循环执行两次,分别打印出1, 2\n}\n```\n### RegExp.prototype.exec()\n\nexec() 方法在一个指定字符串中执行一个搜索匹配.\n\n**语法**\n```\nregexObj.exec(str)\n```\n**返回值:**\n\n1.如果匹配失败，返回 null。\n2.如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的属性,一般来说主要是lastIndex属性值的更新。返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面,返回值虽然是Array实例,但是包含了index和input属性\n\nindex: 表示匹配项在字符串中的位置,也就是匹配项第一个字符的位置\ninput: 表示应用正则表达式的字符串\n\n#### 非全局调用\n\n返回数组内容包括:\n1. 第一个元素是与正则表达式相匹配的文本\n2. 第二个元素是与正则对象第一个子表达式相匹配的文本,也就是第一个分组(如果有的话)\n2. 第三个元素是与正则对象第二个子表达式相匹配的文本,也就是第而个分组(如果有的话),以此类推\n\n```\nvar reg = /\\d(\\w)(\\w)\\d/;\nvar str = '@1bb2c3dd4f';\nvar res = reg.exec(str);\nconsole.log(reg.lastIndex);  // 0  非全局模式忽略lastIndex属性\nconsole.log(res.index);  // 1\nconsole.log(res.input);  // @1ab2c3dd4f\nconsole.log(res);  // [\"1ab2\", \"a\", \"b\"]\n```\n\n#### 全局调用\n\n```\nvar reg = /\\d(\\w)(\\w)\\d/g;\nvar str = '@1bb2c3dd4f';\nvar res = reg.exec(str);\nconsole.log(reg.lastIndex);  // 5  非全局模式忽略lastIndex属性\nconsole.log(res.index);  // 1\nconsole.log(res.input);  // @1ab2c3dd4f\nconsole.log(res);  // [\"1ab2\", \"a\", \"b\"]\nconsole.log(reg.lastIndex); \n```\n使用while循环加深一下理解\n```\nvar reg = /\\d(\\w)(\\w)\\d/g;\nvar str = '@1bb2c3dd4f';\nwhile(reg.exec(str)) {\n    console.log(reg.lastIndex, res.index, res);\n    // 打印两次结果分别为\n    // 5, 1, [\"1bb2\", \"b\", \"b\"]\n    // 10, 6, [\"3dd4\", \"d\", \"d\"]\n}\n```\n\n# 字符串对象方法\n\n## String.prototype.search()\n方法执行正则表达式和 String对象之间的一个搜索匹配,如果匹配成功,返回正则表达式在字符串中首次匹配项的索引,否则返回-1。\n\n**语法:**\n```\nstr.search(regexp)\n```\n\n如果传入一个非正则表达式对象，则会使用 new RegExp(obj) 隐式地将其转换为正则表达式对象。\n\n## String.prototype.match()\n\n用于搜索字符串,找到一个或多个与regexp匹配的文本\n**语法:**\n```\nstr.match(regexp);\n```\n\n**返回值:**\n\n一个包含了整个匹配结果以及任何括号捕获的匹配结果的 Array ；如果没有匹配项，则返回 null。regexp是否有g标志对返回值有很大影响。\n\n### 非全局调用(不包含g标志)\n\n返回值和RegExp.prototype.exec()方法一样,就不细说了。\n\n### 全局调用(包含g标志)\n\n1. 没有找到任何匹配的字符串,返回null\n2. 如果找到了一个或多个匹配的字符串,则返回一个数组,存放字符串中所有匹配的字符串,不包含捕获内容,也不具有index和input属性。\n\n```\nvar reg = /\\d(\\w)\\d/g;\nvar str = '1a2b3c4d';\nvar res = str.match(reg);\nconsole.log(res);  // [\"1a2\", \"3c4\"]\nconsole.log(res.index);  // undefined\nconsole.log(res.input);  // undefined\n```\n\n## String.prototype.split()\n\nsplit() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组\n\n**语法:**\n```\nstr.split([separator[, limit]]);\n```\n![split](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-16%20%E4%B8%8A%E5%8D%8810.17.52.png)\n\n### separator 参数\n当separator为字符串时,其实也是默认转成正则去执行\n\n```\nvar str = 'a, b, c, d';\nvar arr = str.split(',');\nvar arr2 = str.split(/,/);\nconsole.log(arr);  // [\"a\", \" b\", \" c\", \" d\"]\nconsole.log(arr2);  // [\"a\", \" b\", \" c\", \" d\"]\n``` \n### separator带捕获括号\n如果 separator 包含捕获括号（capturing parentheses），则其匹配结果将会包含在返回的数组中。\n```\nvar str = 'a1b2c3d';\nvar arr = str.split(/(\\d)/);\nconsole.log(arr); // [\"a\", \"1\", \"b\", \"2\", \"c\", \"3\", \"d\"]\n```\n\n### limit参数\n限制返回值中分割元素数量\n```\nvar str = 'a b c d e';\nvar arr = str.split(' ', 3);\nconsole.log(arr); //  [\"a\", \"b\", \"c\"]\n```\n\n## String.prototype.replace()\n\nreplace() 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串。模式可以是一个字符串或者一个正则表达式, 替换值可以是一个字符串或者一个每次匹配都要调用的函数。\n\n**注意:** 原字符串不会改变。\n\n**语法:**\n\n```\nstr.replace(regexp|substr, newSubStr|function)\n```\n###  String.prototype.replace(substr, newSubStr) \n\n```\nvar str = 'a1b2c3d';\nvar resStr = str.replace('1', 'X');\nconsole.log(resStr); //  \n```\n###  String.prototype.replace(regexp, newSubStr)  \n```\nvar str = 'a1b2c3d';\nvar resStr = str.replace(/\\d/g, 'X');\nconsole.log(resStr); //  aXbXcXd\n```\n###  String.prototype.replace(regexp, function)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n\nfunction会在每次匹配替换的时候调用,包含四个可选参数\n\n1. 匹配到的字符串\n2. 正则表达式分组内容,没有分组就没有该参数\n3. 匹配项在字符串中的index\n4. 原字符串\n\n**例子:**\n\n比如要把'a1b2c3'替换后的结果为'a2b3c4'\n\n```\nvar str = 'a1b2c3';\nvar resStr = str.replace(/\\d/g, function(matchStr, index, originStr) {\n    // 此时正则表达式中无捕获,function中则无分组参数\n    return parseInt(matchStr) + 1;\n});\nconsole.log(resStr); // a2b3c4\n```\n\n当正则表达式中有捕获时,再看一下另外一个例子:\n```\nvar str = 'a1b2c3d4e';\nvar resStr = str.replace(/(\\d)(\\w)(\\d)/g, function(matchStr, group1, group2, group3, index, originStr) {\n    // 会执行两次回调,打印结果分别如下\n    console.log(matchStr)  // 1b2   3d4\n    console.log(group1);   // 1     3\n    console.log(group2);   // b     d\n    console.log(group3);   // 2     4\n    return group1 + group3; //把匹配到的文本替换成group1 + group3字符串拼接后的值\n});\n// 把匹配到的1b2替换成group1 + group3(12), 3d4替换成(34)\nconsole.log(resStr); // a12c34e  把匹配到的1b2替换成group1 + group3(12)\n```\n\n以上就是我总结的正则表达式相关知识,感觉把正则搞清楚还是很爽滴, 如发现有问题请多多指教。\n\n  ",
    "category_name": "javaScript",
    "isSaved": "2",
    "date": new Date(1515144140779),
    "__v": 0
}, {
    "_id": "5a4f43e6c4780dbc7f6b4f54",
    "article_id": "5a4f43dac4780dbc7f6b4f53",
    "article_title": "js中的闭包",
    "article_content": "文章同步到[github](https://github.com/sunzhaoye/blog/issues/12)\n\njs的闭包概念几乎是任何面试官都会问的问题,最近把闭包这块的概念梳理了一下,记录成以下文章。\n\n# 什么是闭包\n\n我先列出一些官方及经典书籍等书中给出的概念,这些概念虽然表达的不一样,但是都在对闭包做了最正确的定义和翻译,也帮助大家更好的理解闭包,这阅读起来可能比较模糊,大家往后看,本文通过对多个经典书籍中的例子讲解,相信会让大家能很好的理解js中的闭包。文章开始,我会先铺垫一下闭包的概念和为什么要引入闭包的概念,然后结合例子来说明讲解,并讲解如何使用闭包。\n\n## 百度百科中的定义: \n        \n[闭包](https://baike.baidu.com/item/%E9%97%AD%E5%8C%85/10908873?fr=aladdin)包含自由（未绑定到特定对象）变量；这些变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。“闭包” 一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域) -- 百度百科\n\n## 《javaScript权威指南》中的概念:\n函数对象可以通过作用域链互相关联起来,函数体内部的变量都可以保存在函数作用域内,这种特性在计算机科学中成为**闭包**\n\n## 《javaScript高级教程》中概念:\n闭包是指有权访问另一个函数作用域中的变量的函数。\n\n## MDN中的概念\n\n![MDN闭包](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-18%20%E4%B8%8B%E5%8D%884.59.09.png)\n\n## 个人总结的闭包概念:\n1. 闭包就是子函数可以有权访问父函数的变量、父函数的父函数的变量、一直到全局变量。归根结底,就是利用js得词法(静态)作用域,即作用域链在函数创建的时候就确定了。\n2. 子函数如果不被销毁,整条作用域链上的变量仍然保存在内存中。\n\n# 为什么引入闭包的概念\n\n我引入[《深入理解JavaScript系列:闭包(Closures)》](http://www.lai18.com/content/425670.html)文章中的例子来说明,也可以直接去看那篇文章,我结合其他书籍反复读了很多遍此文章才理解清楚。如下:\n\n```\nfunction testFn() {\n\n  var localVar = 10;  // 自由变量\n\n  function innerFn(innerParam) {\n    alert(innerParam + localVar);\n  }\n\n  return innerFn;\n}\n\nvar someFn = testFn();\nsomeFn(20); // 30\n```\n**一般来说,在函数执行完毕之后,局部变量对象即被销毁,所以innerFn是不可能以返回值形式返回的,innerFn函数作为局部变量应该被销毁才对。**\n\n这是当函数以返回值时的问题,另外再看一个当函数以参数形式使用时的问题,还是直接引用《深入理解JavaScript系列》中的例子,也方便大家有兴趣可以直接去阅读那篇文章\n\n```\nvar z = 10;\n\nfunction foo() {\n  alert(z);\n}\n\nfoo(); // 10 – 使用静态和动态作用域的时候\n\n(function () {\n\n  var z = 20;\n  foo(); // 10 – 使用静态作用域, 20 – 使用动态作用域\n\n})();\n\n// 将foo作为参数的时候是一样的\n(function (funArg) {\n\n  var z = 30;\n  funArg(); // 10 – 静态作用域, 30 – 动态作用域\n\n})(foo);\n```\n当函数foo在不同的函数中调用,z该取哪个上下文中的值呢,这就又是一个问题,所以就引入了闭包的概念,也可以理解为定义了一种规则。\n\n# 理解闭包\n\n## 函数以返回值返回\n\n看一个《javsScript权威指南》中的一个例子,我稍微做一下修改如下:\n```\nvar scope = 'global scope';\nfunction checkScope() {\n    var scope = 'local scope';\n    return function() {\n        console.log(scope);\n    }\n}\n\nvar result = checkScope(); \nresult();   // local scope  checkScope变量对象中的scope,非全局变量scope\n```\n**分析:**\n\n即使匿名函数是在checkScope函数外调用,也没有使用全局变量scope,即是利用了js的静态作用域,当匿名函数初始化时,就创建了自己的作用域链(作用域链的概念这里不做解释,可以参考我的另一篇文章[js中的执行栈、执行环境(上下文)、作用域、作用域链、活动对象、变量对象的概念总结](https://segmentfault.com/a/1190000011082342),其实当把作用域链理解好了之后,闭包也就理解了), 此匿名函数的作用域链包括checkScope的活动对象和全局变量对象, 当checkScope函数执行完毕后,checkScope的活动对象并不会被销毁,因为匿名函数的作用域链还在引用checkScope的活动对象,也就是checkScope的执行环境被销毁,但是其活动对象没有被销毁,留存在堆内存中,直到匿名函数销毁后,checkScope的活动对象才会销毁,解除对匿名函数的引用将其设置为null即可,垃圾回收将会将其清除,另外当外部对checkScope的自由变量存在引用的时候,其活动对象也不会被销毁\n\n```\nresult = null; //解除对匿名函数的引用\n```\n**注释:**\n\n自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量\n\n**补充:**\n引用一下《javsScript权威指南》中的补充,帮助大家进一步理解\n![闭包](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-18%20%E4%B8%8B%E5%8D%883.40.00.png)\n\n## 函数以参数形式使用\n\n当函数以参数形式使用时一般用于利用闭包特性解决实际问题,比如浏览器中内置的方法等,下面我直接引用《深入理解JavaScript系列:闭包(Closures)》中关于闭包实战部分的例子如下:\n\n### sort\n\n在sort的内置方法中,函数以参数形式传入回调函数,在sort的实现中调用:\n```\n[1, 2, 3].sort(function (a, b) {\n  ... // 排序条件\n});\n```\n### map\n和sort的实现一样\n```\n[1, 2, 3].map(function (element) {\n  return element * 2;\n}); // [2, 4, 6]\n```\n\n### 另外利用自执行匿名函数创建的闭包\n\n```\nvar foo = {};\n\n// 初始化\n(function (object) {\n\n  var x = 10;\n\n  object.getX = function() {\n    return x;\n  };\n\n})(foo);\n\nalert(foo.getX()); // 获得闭包 \"x\" – 10\n```\n\n# 利用闭包实现私有属性的存取\n\n先来看一个例子\n\n```\nvar fnBox = [];\nfunction foo() {\n    for(var i = 0; i < 3; i++) {\n        fnBox[i] = function() {\n            return i;\n        }\n    }\n}\n\nfoo();\nvar fn0 = fnBox[0];\nvar fn1 = fnBox[1];\nvar fn2 = fnBox[2];\nconsole.log(fn0()); //  3\nconsole.log(fn1()); //  3\nconsole.log(fn2()); //  3\n```\n用伪代码来说明如下:\n```\nfn0.[[scope]]= {\n    // 其他变量对象,一直到全局变量对象\n    父级上下文中的活动对象AO: [data: [...], i: 3]\n}\n\nfn1.[[scope]]= {\n    // 其他变量对象,一直到全局变量对象\n    父级上下文中的活动对象AO: [data: [...], i: 3]\n}\n\nfn2.[[scope]]= {\n    // 其他变量对象,一直到全局变量对象\n    父级上下文中的活动对象AO: [data: [...], i: 3],\n}\n```\n**分析:**\n\n这是因为fn0、fn1、fn2的作用域链共享foo的活动对象, 而且js没有块级作用域,当函数foo执行完毕的时候foo的活动对象中i的值已经变为3,当fn0、fn1、fn2执行的时候,其最顶层的作用域没有i变量,就沿着作用域链查找foo的活动对象中的i,所以i都为3。\n\n但是这种结果往往不是我们想要的,这时就可以利用认为创建一个闭包来解决这个问题,如下:\n```\nvar fnBox = [];\nfunction foo() {\n    for(var i = 0; i < 3; i++) {\n        fnBox[i] = (function(num) {\n            return function() {\n                return num;\n            }\n        })(i);\n    }\n}\nfoo();\nvar fn0 = fnBox[0];\nvar fn1 = fnBox[1];\nvar fn2 = fnBox[2];\nconsole.log(fn0()); //  0\nconsole.log(fn1()); //  1\nconsole.log(fn2()); //  2\n```\n用伪代码来说明如下:\n```\nfn0.[[scope]]= {\n    // 其他变量对象,一直到全局变量对象\n    父级上下文中的活动对象AO: [data: [...], k: 3],\n    fn0本身的活动对象AO: {num: 0} \n}\n\nfn1.[[scope]]= {\n    // 其他变量对象,一直到全局变量对象\n    父级上下文中的活动对象AO: [data: [...], k: 3],\n    fn1本身的活动对象AO: {num: 1} \n}\n\nfn2.[[scope]]= {\n    // 其他变量对象,一直到全局变量对象\n    父级上下文中的活动对象AO: [data: [...], k: 3],\n    fn2本身的活动对象AO: {num: 2} \n}\n```\n**分析:**\n\n当使用自执行匿名函数创建闭包, 传入i的值赋值给num,由于作用域链是在函数初始化时创建的,所以当每次循环时,函数fn10、fn1、fn2的作用域链中保存了当次循环是num的值, 当fn10、fn1、fn2调用时,是按照本身的作用域链进行查找。\n\n# 闭包引起的内存泄漏\n\n![闭包内存泄漏](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-10-18%20%E4%B8%8B%E5%8D%884.38.30.png)\n\n# 总结\n\n从理论的角度将,由于js作用域链的特性,js中所有函数都是闭包,但是从应用的角度来说,只有当函数以返回值返回、或者当函数以参数形式使用、或者当函数中自由变量在函数外被引用时,才能成为明确意义上的闭包。\n\n最后,我想表达的式,本篇大量引用和罗列了经典的犀牛书《javaScript权威指南》、红宝书《javaScript高级教程》、以及《深入理解JavaScript系列:闭包(Closures)》系列文章中的概念和例子,不为能形成自己的独特见解,只为了能把闭包清晰的讲解出来。笔者是个小菜鸟,能力实在有限,也在学习中,希望大家多多指点,如发现错误,请多多指正。也希望看过此文的朋友能对闭包多一些理解,那我写这篇文章也就值得了。下次面试时就可以告诉面试官什么是闭包了。谢谢。\n  ",
    "category_name": "javaScript",
    "isSaved": "2",
    "date": new Date(1515144166914),
    "__v": 0
}]

module.exports = {
    articleList: articleList,
    articleContentList: articleContentList
}